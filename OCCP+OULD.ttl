@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@base <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1> .
@prefix sh:     <http://www.w3.org/ns/shacl#> .
@prefix time:   <http://www.w3.org/2006/time#> .
@prefix osh:    <http://www.occpshape.de/shape#> .
@prefix oush: <http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD/shape#> .
@prefix ould: <http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#> .

<http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1> rdf:type owl:Ontology ;
                                                                        owl:imports <http://www.w3.org/2006/time#> ;
                                                                        rdfs:comment "First workaround to implement time tracking features to models"@en .

#################################################################
#    Object Properties
#################################################################

	###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#after
	occp:after rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#after> ;
		owl:inverseOf occp:before ;
		rdfs:domain <http://www.w3.org/2006/time#TemporalEntity> ;
		rdfs:range <http://www.w3.org/2006/time#TemporalEntity> ;
		rdf:type owl:TransitiveProperty ;
		rdfs:comment "This property represents a transitive relation between temporal entities, used to ensure that if A occurs after B and B occurs after C, then A occurs after C."@en ;
		rdfs:label "after (transitive)"@en .


	###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#before
	occp:before rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#before> ;
		owl:inverseOf occp:after ;
		rdfs:domain <http://www.w3.org/2006/time#TemporalEntity> ;
		rdfs:range <http://www.w3.org/2006/time#TemporalEntity> ;
		rdf:type owl:TransitiveProperty ;
		rdfs:comment "This property represents a transitive relation between temporal entities, used to ensure that if A occurs before B and B occurs before C, then A occurs before C."@en ;
		rdfs:label "before (transitive)"@en .


	###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#beginsAfter
	occp:beginsAfter rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasBeginning> ;
		rdfs:domain <http://www.w3.org/2006/time#Interval> ;
		rdfs:range <http://www.w3.org/2006/time#TemporalEntity> ;
		owl:inverseOf occp:beginsBefore ;
		rdf:type owl:TransitiveProperty ;
		rdfs:comment "This property represents the chronological order of beginnings between two temporal entities, used to indicate that T1’s beginning occurs after T2’s beginning, without defining the order of their ends."@en ;
		rdfs:label "begins after"@en .


	###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#beginsBefore
	occp:beginsBefore rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasBeginning> ;
		rdfs:domain <http://www.w3.org/2006/time#Interval> ;
		rdfs:range <http://www.w3.org/2006/time#TemporalEntity> ;
		owl:inverseOf occp:beginsAfter ;
		rdf:type owl:TransitiveProperty ;
		rdfs:comment "This property represents the chronological order of beginnings between two temporal entities, used to indicate that T1’s beginning occurs before T2’s beginning, without defining the order of their ends."@en ;
		rdfs:label "begins before"@en .


	###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#beginsWith
	occp:beginsWith rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasBeginning> ;
		rdfs:domain <http://www.w3.org/2006/time#Interval> ;
		rdfs:range <http://www.w3.org/2006/time#TemporalEntity> ;
		rdfs:comment "This property represents the chronological order of beginnings between two temporal entities, used to indicate that T1’s beginning occurs on the same day as T2’s beginning, without defining the order of their ends."@en ;
		rdfs:label "begins with"@en .


	###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#belongsToLifeCycle							
	occp:belongsToLifeCycle rdf:type owl:ObjectProperty ;
		rdfs:domain <http://www.w3.org/2006/time#TemporalEntity> ;
		rdfs:range occp:LifeCycle ;
		rdfs:comment "This property represents the connection of a phase or instant (mainly transitions) to its lifecycle, used to link temporal entities to the overarching lifecycle they belong to."@en ;
		rdfs:label "belongs to lifecycle"@en .								


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#belongsToPhase
    occp:belongsToPhase rdf:type owl:ObjectProperty ;
		rdfs:domain <http://www.w3.org/2006/time#Instant> ;
		rdfs:range occp:Phase ;
		rdfs:comment "This property represents the connection between an instant and a phase, used to link time instants to their respective phases."@en ;
		rdfs:label "belongs to phase"@en .


	###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#endsAfter
	occp:endsAfter rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasEnd> ;
		rdfs:domain <http://www.w3.org/2006/time#Interval> ;
		rdfs:range <http://www.w3.org/2006/time#TemporalEntity> ;
		owl:inverseOf occp:endsBefore ;
		rdf:type owl:TransitiveProperty ;
		rdfs:comment "This property represents the chronological order of endings between two temporal entities, used to indicate that T1’s end occurs after T2’s end, without defining the order of their beginnings."@en ;
		rdfs:label "ends after"@en .


	###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#endsBefore
	occp:endsBefore rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasEnd> ;
		rdfs:domain <http://www.w3.org/2006/time#Interval> ;
		rdfs:range <http://www.w3.org/2006/time#TemporalEntity> ;
		owl:inverseOf occp:endsAfter ;
		rdf:type owl:TransitiveProperty ;
		rdfs:comment "This property represents the chronological order of endings between two temporal entities, used to indicate that T1’s end occurs before T2’s end, without defining the order of their beginnings."@en ;
		rdfs:label "ends before"@en .


	###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#endsCycle
	occp:endsCycle rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasEnd> ;
		rdfs:domain <http://www.w3.org/2006/time#Instant> ;
		rdfs:range occp:Cycle ;
		rdfs:comment "This property represents the relationship between an instant and a cycle, used to mark instants that end an ongoing cycle within a phase."@en ;
		rdfs:label "ends cycle"@en .


	###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#endsPhase
	occp:endsPhase rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasEnd> ;
		rdfs:domain <http://www.w3.org/2006/time#Instant> ;
		rdfs:range occp:Phase ;
		rdfs:comment "This property represents the relationship between an instant and a phase, used to mark instants that end an ongoing phase."@en ;
		rdfs:label "ends phase"@en .


	###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#endsWith
	occp:endsWith rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasEnd> ;
		rdfs:domain <http://www.w3.org/2006/time#Interval> ;
		rdfs:range <http://www.w3.org/2006/time#TemporalEntity> ;
		rdfs:comment "This property represents the chronological order of endings between two temporal entities, used to indicate that T1’s end occurs on the same day as T2’s end, without defining the order of their beginnings."@en ;
		rdfs:label "ends with"@en .


	###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#hasActualBeginning
	occp:hasActualBeginning rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasBeginning> ;
		rdfs:domain <http://www.w3.org/2006/time#Interval> ;
		rdfs:range <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This property represents the connection between an interval and an instant, used to mark the actual beginning of a phase."@en ;
		rdfs:label "has actual beginning"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#hasActualEnd
    occp:hasActualEnd rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasEnd> ;
		rdfs:domain <http://www.w3.org/2006/time#Interval> ;
		rdfs:range  <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This property represents the connection between an interval and an instant, used to mark the actual end of a phase."@en ;
		rdfs:label "has actual end"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#hasActualTime
    occp:hasActualTime rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasTime> ;
		rdfs:domain <http://www.w3.org/2006/time#Instant> ;
		rdfs:range  xsd:date ;
		rdfs:comment "This property represents the connection between an instant and a date, used to mark the actual point in time of an instant."@en ;
		rdfs:label "has actual time"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#hasCycle
    occp:hasCycle rdf:type owl:ObjectProperty ;
		rdfs:range occp:Cycle ;
		rdfs:comment "This property represents the connection between a model (component) and a cycle."@en ;
		rdfs:label "has cycle"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#hasEstimatedBeginning
    occp:hasEstimatedBeginning rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasBeginning> ;
		rdfs:domain <http://www.w3.org/2006/time#Interval> ;
		rdfs:range  <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This property represents the connection between an interval and an instant, used to mark the estimated beginning of a phase."@en ;
		rdfs:label "has estimated beginning"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#hasEstimatedEnd
    occp:hasEstimatedEnd rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasEnd> ;
		rdfs:domain <http://www.w3.org/2006/time#Interval> ;
		rdfs:range  <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This property represents the connection between an interval and an instant, used to mark the estimated end of a phase."@en ;
		rdfs:label "has estimated end"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#hasEstimatedTime
    occp:hasEstimatedTime rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasTime> ;
		rdfs:domain <http://www.w3.org/2006/time#Instant> ;
		rdfs:range  xsd:date ;
		rdfs:comment "This property represents the connection between an instant and a date, used to mark the estimated point in time of an instant."@en ;
		rdfs:label "has estimated time"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#hasInstant
    occp:hasInstant rdf:type owl:ObjectProperty ;
		rdfs:range <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This property represents the link between an updatable entity and an instant, used to connect specific lifecycle events (e.g., Submission) from the MsOCCP to components or models."@en ;
		rdfs:label "has instant"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#hasLifecycle
    occp:hasLifecycle a rdf:Property ;
        rdfs:domain occp:Phase ;
        rdfs:range occp:Lifecycle ;
		owl:inverseOf occp:isInPhase ;
        rdfs:comment "Links a phase to a specific lifecycle." ;
        rdfs:label "has Lifecycle" .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#hasPhase
    occp:hasPhase rdf:type owl:ObjectProperty ;
		rdfs:range occp:Phase ;
		rdfs:comment "This property represents the connection between a model (component) and a phase."@en ;
		rdfs:label "has phase"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#isInPhase
    occp:isInPhase rdf:type owl:ObjectProperty ;
		rdfs:domain occp:LifeCycle ;
		rdfs:range occp:Phase ;
		rdfs:comment "This property represents the embedding of a lifecycle within a phase, used to link a lifecycle to the overarching phase it belongs to."@en ;
		rdfs:label "is in phase"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#startsCycle
    occp:startsCycle rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasBeginning> ;
		rdfs:domain <http://www.w3.org/2006/time#Instant> ;
		rdfs:range occp:Cycle ;
		rdfs:comment "This property represents the relationship between an instant and a cycle, used to mark instants that start a new cycle within a phase."@en ;
		rdfs:label "starts cycle"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#startsPhase
    occp:startsPhase rdf:type owl:ObjectProperty ;
		rdfs:subPropertyOf <http://www.w3.org/2006/time#hasBeginning> ;
		rdfs:domain <http://www.w3.org/2006/time#Instant> ;
		rdfs:range occp:Phase ;
		rdfs:comment "This property represents the relationship between an instant and a phase, used to mark instants that start a new phase."@en ;
		rdfs:label "starts phase"@en . 


#################################################################
#    Datatype Properties
#################################################################

    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#hasCycleNumber
    occp:hasCycleNumber rdf:type owl:DatatypeProperty ;
		rdfs:domain occp:Cycle ;
		rdfs:range xsd:integer ;
		rdfs:comment "This property represents the number of iterations in a cycle, used to specify how many times a process like a planning review repeats (e.g., in CycleA_PlanningReview)."@en ;
		rdfs:label "has cycle number"@en .


	###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#hasLifeCycleID
	occp:hasLifeCycleID rdf:type owl:DatatypeProperty ;
		rdfs:domain occp:LifeCycle ;
		rdfs:range xsd:string ;
		rdfs:comment "This property represents the unique identifier of a lifecycle, used to provide a distinct ID for tracking purposes."@en ;
		rdfs:label "has lifecycle ID"@en .


#################################################################
#    Classes
#################################################################

    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#BeginOfTenderingProcess
    occp:BeginOfTenderingProcess rdf:type owl:Class ;
		rdfs:subClassOf occp:Transition ;
		rdfs:comment "This class represents the instant marking the start of the tendering process, a transition between the planning and construction phases, occurring after the completion of planning."@en ;
		rdfs:label "Begin of Tendering Process"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#BeginningOfPlanning
    occp:BeginningOfPlanning rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseA_Instant ;
		rdfs:comment "This class represents the instant marking the official start of the planning phase."@en ;
		rdfs:label "Beginning of Planning"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#CompletionOfConstruction
    occp:CompletionOfConstruction rdf:type owl:Class ;
		rdfs:subClassOf occp:Transition ;
		rdfs:comment "This class represents the instant marking the last acceptance and finish of construction works, serving as a transition between the construction and usage phases."@en ;
		rdfs:label "Completion of Construction"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#CompletionOfDeconstruction
    occp:CompletionOfDeconstruction rdf:type owl:Class ;
		rdfs:subClassOf occp:Transition ;
		rdfs:comment "This class represents the instant marking the completion of the final deconstruction task, ending the lifecycle of a building or construction."@en ;
		rdfs:label "Completion of Deconstruction"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#CompletionOfPlanning
    occp:CompletionOfPlanning rdf:type owl:Class ;
		rdfs:subClassOf occp:Transition ;
		rdfs:comment "This class represents the instant marking the last planning review acceptance, serving as a transition from the planning phase to the tendering process."@en ;
		rdfs:label "Completion of Planning"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#ConstructionAcceptance
    occp:ConstructionAcceptance rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseC_Instant ;
		rdfs:comment "This class represents the instant marking the final acceptance of a construction or component, occurring after completion or defect elimination."@en ;
		rdfs:label "Construction Acceptance"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#ConstructionCompletion
    occp:ConstructionCompletion rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseC_Instant ;
		rdfs:comment "This class represents the instant marking the completion of construction for a model component or building."@en ;
		rdfs:label "Construction Completion"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#ConstructionStart
    occp:ConstructionStart rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseC_Instant ;
		rdfs:comment "This class represents the instant marking the beginning of construction works for a model component or building."@en ;
		rdfs:label "Construction Start"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#Cycle
    occp:Cycle rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Interval> ;
		rdfs:comment "This class represents a recurring time span with a starting point, period, and duration, used to track iterating processes like multiple planning reviews."@en ;
		rdfs:label "Cycle"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#CycleA_PlanningReview
    occp:CycleA_PlanningReview rdf:type owl:Class ;
		rdfs:subClassOf occp:Cycle ;
		rdfs:comment "This class represents a cycle starting with the review start and ending with approval or rejection, used to track planning and review iterations. Multiple events possible if rejected."@en ;
		rdfs:label "Cycle A Planning Review"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#DamageDetection
    occp:DamageDetection rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseK_Instant ;
		rdfs:comment "This class represents the instant marking the detection of damage affecting a component or building. Multiple events possible."@en ;
		rdfs:label "Damage Detection"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#DamageObservation
    occp:DamageObservation rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseK_Instant ;
		rdfs:comment "This class represents the instant marking the observation of a known defect or damage, typically linked to inspections or monitoring systems. Multiple events possible."@en ;
		rdfs:label "Damage Observation"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#DamageRepair
    occp:DamageRepair rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseK_Instant ;
		rdfs:comment "This class represents the instant marking the repair of a defect or damage, typically coinciding with the end of repair measures."@en ;
		rdfs:label "Damage Repair"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#DataProcurement
    occp:DataProcurement rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseA_Instant ;
		rdfs:comment "This class represents the instant marking data procurement actions, such as geodetic measures or adding data to planning models. Multiple events possible."@en ;
		rdfs:label "Data Procurement"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#DeconstructionCompletion
    occp:DeconstructionCompletion rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseM_Instant ;
		rdfs:comment "This class represents the instant marking the completion of deconstruction works, ending the lifecycle of a component or building."@en ;
		rdfs:label "Deconstruction Completion"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#DeconstructionStart
    occp:DeconstructionStart rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseM_Instant ;
		rdfs:comment "This class represents the instant marking the beginning of deconstruction works for a component or building."@en ;
		rdfs:label "Deconstruction Start"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#DefectElimCompletion
    occp:DefectElimCompletion rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseC_Instant ;
		rdfs:comment "This class represents the instant marking the completion of construction works related to defect elimination for a model component or building."@en ;
		rdfs:label "Defect Elimination Completion"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#DefectElimStart
    occp:DefectElimStart rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseC_Instant ;
		rdfs:comment "This class represents the instant marking the beginning of construction works related to defect elimination for a model component or building."@en ;
		rdfs:label "Defect Elimination Start"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#DesignLifeChange
    occp:DesignLifeChange rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseF_Instant ;
		rdfs:comment "This class represents the instant marking a change in the estimated design life due to factors like repairs or usage changes. Multiple events possible."@en ;
		rdfs:label "Design Life Change"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#DesignLifeEnd
    occp:DesignLifeEnd rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseF_Instant ;
		rdfs:comment "This class represents the instant marking the end of the estimated design life of a component or building. Multiple events possible due to estimation changes."@en ;
		rdfs:label "Design Life End"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#DesignLifeStart
    occp:DesignLifeStart rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseF_Instant ;
		rdfs:comment "This class represents the instant marking the start of the estimated design life of a component or building."@en ;
		rdfs:label "Design Life Start"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#Edit_ASTR
    occp:Edit_ASTR rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseA_Instant ;
		rdfs:comment "This class represents the instant marking significant changes to a planning model after submission to review (ASTR = After Submission To Review). Multiple events possible."@en ;
		rdfs:label "Edit ASTR"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#Edit_BSTR
    occp:Edit_BSTR rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseA_Instant ;
		rdfs:comment "This class represents the instant marking significant changes to a planning model before submission to review (BSTR = Before Submission To Review). Multiple events possible."@en ;
		rdfs:label "Edit BSTR"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#GeologicalEvent
    occp:GeologicalEvent rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseH_Instant ;
		rdfs:comment "This class represents the instant marking a geological event (e.g., earthquake) affecting a component or building. Multiple events possible."@en ;
		rdfs:label "Geological Event"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#InspectionExecution
    occp:InspectionExecution rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseG_Instant ;
		rdfs:comment "This class represents the instant marking the execution of a regular inspection. Multiple events possible over the lifecycle."@en ;
		rdfs:label "Inspection Execution"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#IrregularInspection
    occp:IrregularInspection rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseG_Instant ;
		rdfs:comment "This class represents the instant marking the execution of an irregular inspection. Multiple events possible over the lifecycle."@en ;
		rdfs:label "Irregular Inspection"@en .


	###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#LifeCycle		
	occp:LifeCycle rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Interval> ;
		rdfs:comment "This class represents a complete lifecycle (Phases A to M) within an overarching phase or another lifecycle, identified by a unique ID."@en ;
		rdfs:label "Life Cycle"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#LoadEvent
    occp:LoadEvent rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseH_Instant ;
		rdfs:comment "This class represents the instant marking an irregular load event affecting a component or building. Multiple events possible."@en ;
		rdfs:label "Load Event"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#NewComponent
    occp:NewComponent rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseL_Instant ;
		rdfs:comment "This class represents the instant marking the addition of a new component to an existing structure, potentially initiating a sub-lifecycle. Multiple events possible."@en ;
		rdfs:label "New Component"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#NextRegularInspection
    occp:NextRegularInspection rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseG_Instant ;
		rdfs:comment "This class represents the instant marking the planned date of the next regular inspection, based on the inspection interval. Multiple events possible over the lifecycle."@en ;
		rdfs:label "Next Regular Inspection"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#Phase
    occp:Phase rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Interval> ;
		rdfs:comment "This class represents the main chronological blocks of a building’s lifecycle (e.g., planning, construction, usage), serving as a customizable base structure."@en ;
		rdfs:label "Phase"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseA_Instant
    occp:PhaseA_Instant rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This class represents instants within Phase A (Planning Phase), grouping all related events."@en ;
		rdfs:label "Phase A Instant"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseA_Planning
    occp:PhaseA_Planning rdf:type owl:Class ;
		rdfs:subClassOf occp:Phase ;
		rdfs:comment "This class represents the planning phase, starting with BeginningOfPlanning and ending with CompletionOfPlanning."@en ;
		rdfs:label "Phase A Planning"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseB_Instant
    occp:PhaseB_Instant rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This class represents instants within Phase B (Review Phase), grouping all related events."@en ;
		rdfs:label "Phase B Instant"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseB_Review
    occp:PhaseB_Review rdf:type owl:Class ;
		rdfs:subClassOf occp:Phase ;
		rdfs:comment "This class represents the review phase, starting with the first submission to review and ending with CompletionOfPlanning."@en ;
		rdfs:label "Phase B Review"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseC_Construction
    occp:PhaseC_Construction rdf:type owl:Class ;
		rdfs:subClassOf occp:Phase ;
		rdfs:comment "This class represents the construction phase, starting with ConstructionStart and ending with CompletionOfConstruction."@en ;
		rdfs:label "Phase C Construction"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseC_Instant
    occp:PhaseC_Instant rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This class represents instants within Phase C (Construction Phase), grouping all related events."@en ;
		rdfs:label "Phase C Instant"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseD_Instant
    occp:PhaseD_Instant rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This class represents instants within Phase D (Usage Phase), grouping all related events."@en ;
		rdfs:label "Phase D Instant"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseD_Usage
    occp:PhaseD_Usage rdf:type owl:Class ;
		rdfs:subClassOf occp:Phase ;
		rdfs:comment "This class represents the usage phase, starting with UsageStart and ending with UsageEnd."@en ;
		rdfs:label "Phase D Usage"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseE_Instant
    occp:PhaseE_Instant rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This class represents instants within Phase E (Warranty Phase), grouping all related events."@en ;
		rdfs:label "Phase E Instant"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseE_Warranty
    occp:PhaseE_Warranty rdf:type owl:Class ;
		rdfs:subClassOf occp:Phase ;
		rdfs:comment "This class represents the warranty phase, starting with WarrantyStart and ending with WarrantyEnd."@en ;
		rdfs:label "Phase E Warranty"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseF_DesignLife
    occp:PhaseF_DesignLife rdf:type owl:Class ;
		rdfs:subClassOf occp:Phase ;
		rdfs:comment "This class represents the design life phase, starting with DesignLifeStart and ending with DesignLifeEnd."@en ;
		rdfs:label "Phase F Design Life"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseF_Instant
    occp:PhaseF_Instant rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This class represents instants within Phase F (Design Life Phase), grouping all related events."@en ;
		rdfs:label "Phase F Instant"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseG_Inspection
    occp:PhaseG_Inspection rdf:type owl:Class ;
		rdfs:subClassOf occp:Phase ;
		rdfs:comment "This class represents the inspection phase, starting with the beginning of usage and ending with the beginning of deconstruction."@en ;
		rdfs:label "Phase G Inspection"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseG_Instant
    occp:PhaseG_Instant rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This class represents instants within Phase G (Inspection Phase), grouping all related events."@en ;
		rdfs:label "Phase G Instant"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseH_Instant
    occp:PhaseH_Instant rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This class represents instants within Phase H (Special Events Phase), grouping all related events."@en ;
		rdfs:label "Phase H Instant"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseH_SpecialEvents
    occp:PhaseH_SpecialEvents rdf:type owl:Class ;
		rdfs:subClassOf occp:Phase ;
		rdfs:comment "This class represents the special events phase, starting with the first special event and ending with the last."@en ;
		rdfs:label "Phase H Special Events"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseK_Damage
    occp:PhaseK_Damage rdf:type owl:Class ;
		rdfs:subClassOf occp:Phase ;
		rdfs:comment "This class represents the damage phase, starting with DamageDetection and ending with repair completion or deconstruction start."@en ;
		rdfs:label "Phase K Damage"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseK_Instant
    occp:PhaseK_Instant rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This class represents instants within Phase K (Damage Phase), grouping all related events."@en ;
		rdfs:label "Phase K Instant"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseL_Instant
    occp:PhaseL_Instant rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This class represents instants within Phase L (Repair Phase), grouping all related events."@en ;
		rdfs:label "Phase L Instant"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseL_Repair
    occp:PhaseL_Repair rdf:type owl:Class ;
		rdfs:subClassOf occp:Phase ;
		rdfs:comment "This class represents the repair phase, starting with RepairStart and ending with RepairCompletion."@en ;
		rdfs:label "Phase L Repair"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseM_Deconstruction
    occp:PhaseM_Deconstruction rdf:type owl:Class ;
		rdfs:subClassOf occp:Phase ;
		rdfs:comment "This class represents the deconstruction phase, starting with DeconstructionStart and ending with DeconstructionCompletion."@en ;
		rdfs:label "Phase M Deconstruction"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#PhaseM_Instant
    occp:PhaseM_Instant rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This class represents instants within Phase M (Deconstruction Phase), grouping all related events."@en ;
		rdfs:label "Phase M Instant"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#RepairCompletion
    occp:RepairCompletion rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseL_Instant ;
		rdfs:comment "This class represents the instant marking the completion of damage repair works for a component or building. Multiple events possible."@en ;
		rdfs:label "Repair Completion"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#RepairStart
    occp:RepairStart rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseL_Instant ;
		rdfs:comment "This class represents the instant marking the beginning of damage repair works for a component or building. Multiple events possible."@en ;
		rdfs:label "Repair Start"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#ReviewApproval
    occp:ReviewApproval rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseB_Instant ;
		rdfs:comment "This class represents the instant marking the reviewer’s acceptance of a planning model, ending the planning and review phases."@en ;
		rdfs:label "Review Approval"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#ReviewRejection
    occp:ReviewRejection rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseB_Instant ;
		rdfs:comment "This class represents the instant marking the reviewer’s rejection of a planning model. Multiple events possible."@en ;
		rdfs:label "Review Rejection"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#ReviewStart
    occp:ReviewStart rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseB_Instant ;
		rdfs:comment "This class represents the instant marking the start of the review process. Multiple events possible with rejections."@en ;
		rdfs:label "Review Start"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#Submission
    occp:Submission rdf:type owl:Class ;
		rdfs:subClassOf occp:Transition ;
		rdfs:comment "This class represents the instant marking the end of the tendering process, serving as a transition to the construction phase."@en ;
		rdfs:label "Submission"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#SubmissionToReview
    occp:SubmissionToReview rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseA_Instant ;
		rdfs:comment "This class represents the instant marking the submission of a planning draft to the reviewer, starting Phase B. Multiple events possible."@en ;
		rdfs:label "Submission to Review"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#Transition
    occp:Transition rdf:type owl:Class ;
		rdfs:subClassOf <http://www.w3.org/2006/time#Instant> ;
		rdfs:comment "This class represents key milestones or triggering events between phases, typically enabling the start of the next phase or marking phase completion."@en ;
		rdfs:label "Transition"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#UsageChange
    occp:UsageChange rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseD_Instant ;
		rdfs:comment "This class represents the instant marking a change in usage of a component or building, potentially ending one or more usage phases and initiating new ones. Multiple events possible."@en ;
		rdfs:label "Usage Change"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#UsageEnd
    occp:UsageEnd rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseD_Instant ;
		rdfs:comment "This class represents the instant marking the end of usage for a component or building. Multiple events possible."@en ;
		rdfs:label "Usage End"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#UsageStart
    occp:UsageStart rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseD_Instant ;
		rdfs:comment "This class represents the instant marking the beginning of usage for a component or building. Multiple events possible."@en ;
		rdfs:label "Usage Start"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#WarrantyChange
    occp:WarrantyChange rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseE_Instant ;
		rdfs:comment "This class represents the instant marking a change in warranty due to repairs or extensions. Multiple events possible."@en ;
		rdfs:label "Warranty Change"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#WarrantyEnd
    occp:WarrantyEnd rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseE_Instant ;
		rdfs:comment "This class represents the instant marking the end of a warranty period for a component or building. Multiple events possible due to restarts."@en ;
		rdfs:label "Warranty End"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#WarrantyStart
    occp:WarrantyStart rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseE_Instant ;
		rdfs:comment "This class represents the instant marking the beginning of a warranty period for a component or building. Multiple events possible due to restarts."@en ;
		rdfs:label "Warranty Start"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#WeatherEvent
    occp:WeatherEvent rdf:type owl:Class ;
		rdfs:subClassOf occp:PhaseH_Instant ;
		rdfs:comment "This class represents the instant marking a weather event (e.g., flood) affecting a component or building. Multiple events possible."@en ;
		rdfs:label "Weather Event"@en .


#################################################################
#    Object Properties
#################################################################

    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#consistsOf
    ould:consistsOf a owl:ObjectProperty ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range ould:UpdatableEntity ;
        rdfs:label "consists of"@en ;
        rdfs:comment "Indicates that an entity consists of another entity as a component."@en .

    
    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasLinkedData
    ould:hasLinkedData rdf:type owl:ObjectProperty ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range ould:LinkedData ;
        rdfs:comment "Links an IFC component to an external dataset, document, or other reference stored either online or locally (see also: ould:hasOnlineData and ould:hasOfflineData for online/offline specifics)."@en ;
        rdfs:label "has linked data"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasUpdate
    ould:hasUpdate rdf:type owl:ObjectProperty ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range ould:Update ;
        rdfs:comment "Connects an UpdatableEntity to an existing Update. If a prior Update exists, a new UpdateChain is initiated to track subsequent modifications."@en ;
        rdfs:label "has update"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasPredecessor
    ould:hasPredecessor rdf:type owl:ObjectProperty ;
        rdfs:subPropertyOf ould:hasUpdate ;
        rdfs:domain ould:Update ;
        rdfs:range ould:Update ;
        owl:inverseOf ould:hasSuccessor ;
        rdf:type owl:TransitiveProperty ;
        rdfs:comment "Links an update to its predecessor, enabling chronological tracking of entity changes (e.g., replacements or modifications). The predecessor is an update entry recording the prior state."@en ;
        rdfs:label "has predecessor"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasSuccessor
    ould:hasSuccessor rdf:type owl:ObjectProperty ;
        rdfs:subPropertyOf ould:hasUpdate ;
        rdfs:domain ould:Update ;
        rdfs:range ould:Update;
        owl:inverseOf ould:hasPredecessor ;
        rdf:type owl:TransitiveProperty ;
        rdfs:comment "Links an update to a subsequent update, enabling chronological tracking of entity changes (e.g., replacements or modifications)."@en ;
        rdfs:label "has successor"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasUpdatedValue
    ould:hasUpdatedValue rdf:type owl:ObjectProperty ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range owl:Thing ;
        rdfs:comment "The object property \"hasUpdatedValue\" links to an update to any modified value (e.g., hash, timestamp, IFC-ID, linked data, or temporal entity) recorded in an MsOCCP context."@en ;
        rdfs:label "has updated value"@en .
    

    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasUpdatedEvent
    ould:hasUpdatedEvent rdf:type owl:ObjectProperty ;
        rdfs:subPropertyOf ould:hasUpdatedValue ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range <http://www.w3.org/2006/time#TemporalEntity> ;
        rdfs:comment "The object property \"hasUpdatedEvent\" links a temporal entity (phase, cycle, transition, or instant) to an update typically recorded in an MsOCCP (Model-specific OCCP) file. It enables chronological tracking of modifications to lifecycle data (e.g., updates to time:hasTime or occp:hasEstimatedEnd), ensuring the integrity of time-based records."@en ;
        rdfs:label "has updated event"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasNewValue
    ould:hasNewValue rdf:type owl:ObjectProperty ;
        rdfs:subPropertyOf ould:hasUpdatedValue ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range owl:Thing ;
        owl:inverseOf ould:hasPreviousValue ;
        rdfs:comment "Links an update to the newly recorded value of a modified property."@en ;
        rdfs:label "has new value"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasPreviousValue
    ould:hasPreviousValue rdf:type owl:ObjectProperty ;
        rdfs:subPropertyOf ould:hasUpdatedValue ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range owl:Thing ;
        owl:inverseOf ould:hasNewValue ;
        rdfs:comment "Links an update to the previous recorded value of a modified property."@en ;
        rdfs:label "has previous value"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasPreviousChain
    ould:hasPreviousChain rdf:type owl:ObjectProperty ;
        owl:inverseOf ould:hasNextChain ;
        rdf:type owl:TransitiveProperty ;
        rdfs:domain ould:UpdateChain ;
        rdfs:range ould:UpdateChain ;
        rdfs:comment "The object property \"hasPreviousChain\" links an UpdateChain instance to its predecessor, forming a chronological sequence of modifications. Due to its transitive nature, it enables deep tracking of changes across multiple update cycles, e.g., linking sequential modifications of an IFC component."@en ;
        rdfs:label "has previous chain"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasNextChain
    ould:hasNextChain rdf:type owl:ObjectProperty ;
        owl:inverseOf ould:hasPreviousChain ;
        rdf:type owl:TransitiveProperty ;
        rdfs:domain ould:UpdateChain ;
        rdfs:range ould:UpdateChain ;
        rdfs:comment "The object property \"hasNextChain\" links an UpdateChain instance   to its successor, enabling the structured progression of modification records. Its transitivity ensures complete traceability over multiple updates."@en ;
        rdfs:label "has next chain"@en .    


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasUpdateChain
    ould:hasUpdateChain rdf:type owl:ObjectProperty ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range ould:UpdateChain ;
        rdfs:comment "The object property \"hasUpdateChain\" links an UpdatableEntity to an \"UpdateChain\", grouping multiple related Updates (in contrast to ould:hasUpdate for single Updates)."@en ;
        rdfs:label "has update chain"@en .  


#################################################################
#    Data properties
#################################################################


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#entryTime
    ould:entryTime rdf:type owl:DatatypeProperty ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range xsd:dateTime ;
        rdfs:comment "Specifies the timestamp (YYYY-MM-DDThh:mm:ss) when an entry was made in the MsOCCP for the entity."@en ;
        rdfs:label "entry time"@en .
    
    
    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasOnlineData
    ould:hasOnlineData rdf:type owl:DatatypeProperty ;
        rdfs:subPropertyOf ould:hasLinkedData ; 
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range xsd:anyURI ;
        rdfs:comment "Links an IFC component to an external dataset, document, or other reference stored online."@en ;
        rdfs:label "has online data"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasOfflineData
    ould:hasOfflineData rdf:type owl:DatatypeProperty ;
        rdfs:subPropertyOf ould:hasLinkedData ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range xsd:string ;
        rdfs:comment "Links an IFC component to an external dataset, document, or other reference stored offline."@en ;
        rdfs:label "has offline data"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasDataLocation
    ould:hasDataLocation rdf:type owl:DatatypeProperty ;
        rdfs:domain ould:LinkedData ;
        rdfs:range xsd:string ;
        rdfs:comment "The data property \"hasDataLocation\" specifies the location of the linked data and is used in conjunction with ould:hasOnlineData or ould:hasOfflineData to specify the exact location. It can be a URI (for online storage) or a local file path (for offline storage)."@en ;
        rdfs:label "has data location"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasHash
    ould:hasHash rdf:type owl:DatatypeProperty ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range xsd:string ;
        rdfs:comment "The data property \"hasHash\" is used to store the hash value of an IFC model to record the current state of a IFC model. The hash value is also used to check for changes of the IFC model to ensure the consistency of the chronology."@en ;
        rdfs:label "has hash"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasIFCID
    ould:hasIFCID rdf:type owl:DatatypeProperty ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range xsd:string ;
        rdfs:comment "The data property \"hasIFCID\" is used to store the IFC Identifier (e.g., the IFC component's GlobalID) of a component to record and establish a connection between an IFC component and the MsOCCP (Model-specific OCCP)."@en ;
        rdfs:label "has IFC ID"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasNewHash
    ould:hasNewHash rdf:type owl:DatatypeProperty ;
        rdfs:subPropertyOf ould:hasHash ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range xsd:string ;
        rdfs:comment "The data property \"hasNewHash\" is used to update an existing hash value of an IFC component to record and establish a connection between the old and the new hash. It is used in combination with ould:hasPreviousHash."@en ;
        rdfs:label "has new hash"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasNewIFCID
    ould:hasNewIFCID rdf:type owl:DatatypeProperty ;
        rdfs:subPropertyOf ould:hasIFCID ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range xsd:string ;
        rdfs:comment "The data property \"hasNewIFCID\" is used to store the IFC new Identifier (e.g., the IFC component's GlobalID) of a component to record and establish a connection between the old and the new ID. It is used in combination with ould:hasPreviousIFCID."@en ;
        rdfs:label "has new IFC ID"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasNewTime
    ould:hasNewTime rdf:type owl:DatatypeProperty ;
        rdfs:subPropertyOf <http://www.w3.org/2006/time#hasTime> ;
        rdfs:domain [ rdf:type owl:Class ;
                        owl:unionOf ( ould:Update time:Instant ) ] ;
        rdfs:range xsd:date ;
        rdfs:comment "The data property \"hasNewTime\" is used to record the updated timestamp of an event in an MsOCCP (Model-specific OCCP) file. It ensures that every change to a temporal entity is chronologically documented, allowing for a complete reconstruction of modifications and their sequence."@en ;
        rdfs:label "has new time"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasPreviousTime
    ould:hasPreviousTime rdf:type owl:DatatypeProperty ;
        rdfs:subPropertyOf <http://www.w3.org/2006/time#hasTime> ;
        rdfs:domain [ rdf:type owl:Class ;
                owl:unionOf ( ould:Update time:Instant ) ] ;
        rdfs:range xsd:date ;
        rdfs:comment "The data property \"hasPreviousTime\" is used to record the previously set timestamp (created using the original entry property, e.g., time:hasTime) of an existing and prerecorded event (of which the temporal information needs to be changed/corrected) in an MsOCCP (Model-specific OCCP) file. It can be used to keep track of the chronology of entries, allowing for a complete reconstruction of modifications and their sequence."@en ;
        rdfs:label "has previous time"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasPreviousHash
    ould:hasPreviousHash rdf:type owl:DatatypeProperty ;
        rdfs:subPropertyOf ould:hasHash ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range xsd:string ;
        rdfs:comment "The data property \"hasPreviousHash\" is used to store the old hash value of an IFC component to record and establish a connection between the old and the new hash. It is used in combination with ould:hasNewHash."@en ;
        rdfs:label "has previous hash"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#hasPreviousIFCID
    ould:hasPreviousIFCID rdf:type owl:DatatypeProperty ;
        rdfs:subPropertyOf ould:hasIFCID ;
        rdfs:domain ould:UpdatableEntity ;
        rdfs:range xsd:string ;
        rdfs:comment "The data property \"hasPreviousIFCID\" is used to store the old IFC Identifier (e.g., the IFC component's GlobalID) of a component to record and establish a connection between the old and the new ID. It is used in combination with ould:hasNewIFCID."@en ;
        rdfs:label "has previous IFC ID"@en .


#################################################################
#    Classes
#################################################################


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#LinkedData
    ould:LinkedData rdf:type owl:Class ;
        rdfs:subClassOf ould:UpdatableEntity ;
        rdfs:comment "Represents an external dataset, document, or reference that is linked to an IFC component. This class enables structured integration of additional information into the MsOCCP."@en ;
        rdfs:label "Linked Data"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#UpdatableEntity
    ould:UpdatableEntity rdf:type owl:Class ;
        owl:disjointWith ould:UpdateChain ;
        rdfs:comment "A superclass representing any entity that can undergo updates. This includes IFC components, MsOCCP records, temporal entities and other objects that require chronological modification tracking, e.g., attached or linked data."@en ;
        rdfs:label "Updatable Entity"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#Update
    ould:Update rdf:type owl:Class ;
        rdfs:subClassOf <http://www.w3.org/2006/time#Instant> ;
        rdfs:comment "The class \"Update\" represents a specific modification recorded in an MsOCCP (Model-specific OCCP) file. Each instance captures a single event's transformation, including changes in timestamps, IFC component identifiers, and hash values. By linking to previous updates, it enables full traceability of modifications over time."@en ;
        rdfs:label "Update"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#UpdateChain
    ould:UpdateChain rdf:type owl:Class ;
        owl:disjointWith ould:UpdatableEntity ;
        rdfs:comment "The class \"UpdateChain\" represents a structured sequence of consecutive updates applied to a specific IFC component or dataset. It groups related updates together, enabling an organized way to track modifications over time. Each \"UpdateChain\" instance is linked to previous and next chains, ensuring a complete versioning history. An \"UpdateChain\" is limited to 21 ould:UpdateChainElement(s) for performance reasons."@en ;
        rdfs:label "Update Chain"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#UpdateChainElement
    ould:UpdateChainElement rdf:type owl:Class ;
        rdfs:subClassOf ould:Update ;
        rdfs:comment "The class \"UpdateChainElement\" represents an update that is part of an \"UpdateChain\". It maintains sequential tracking of updates, ensuring chronological integrity of changes to IFC components and other time-bound entities."@en ;
        rdfs:label "Update Chain Element"@en .


    ###  http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#UpdateReplacement
    ould:UpdateReplacement rdf:type owl:Class ;
        rdfs:subClassOf ould:Update ;
        rdfs:comment "Represents an update that replaces one or more existing entities with a new one (e.g., replacing IFC component ifc:Wall123 with ifc:Wall456). It links the predecessor update or entry in the MsOCCP (recording the old state) via ould:hasPredecessor and tracks changes in identifiers and hash values using ould:hasPreviousIFCID, ould:hasNewIFCID, ould:hasPreviousHash, and ould:hasNewHash."@en ;
        rdfs:label "Update Replacement"@en .          



#################################################################
#    SHACL Rules
#################################################################

### GENERAL SHACL RULES

    osh:GeneralDatePropertyShape a sh:PropertyShape ;
        sh:path ( occp:hasActualTime occp:hasEstimatedTime ) ;
        sh:datatype xsd:date ;
        sh:message "Dates must be in YYYY-MM-DD format."@en ;
        sh:severity sh:Violation .

    osh:GeneralTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each entity must have at most one actual beginning via 'occp:hasActualBeginning'."@en ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each entity must have at most one actual end via 'occp:hasActualEnd'."@en ;
            sh:severity sh:Violation ;
        ] .

    osh:PhaseTimeShape a sh:NodeShape ;
        sh:targetClass occp:Phase ;
        sh:or (
            # Case 1: Actual Beginning with Estimated or Actual End
            [ sh:and (
                [ sh:property [
                    sh:path occp:hasActualBeginning ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                ] ]
                [ sh:or (
                    [ sh:property [
                            sh:path occp:hasActualEnd ;
                            sh:minCount 1 ;
                            sh:maxCount 1 ;
                        ] ]
                    [ sh:property [
                            sh:path occp:hasEstimatedEnd ;
                            sh:minCount 1 ;
                        ] ]
                ) ]
            ) ]
            # Case 2: Estimated Beginning with Estimated End
            [ sh:and (
                [ sh:property [
                        sh:path occp:hasEstimatedBeginning ;
                        sh:minCount 1 ;
                    ] ]
                [ sh:property [
                        sh:path occp:hasEstimatedEnd ;
                        sh:minCount 1 ;
                        sh:message "A phase with an estimated beginning must have an estimated end."@en ;
                    ] ]
            ) ]
        ) ;
        sh:message "A phase, if it has an actual beginning, must have an actual or estimated end. If it has an estimated beginning, it must have an estimated end."@en ;
        sh:severity sh:Violation .

    osh:InstantTimeShape a sh:NodeShape ;
        sh:targetClass time:Instant ;
        sh:property [
            sh:path [ sh:alternativePath ( occp:hasActualTime occp:hasEstimatedTime ) ] ;
            sh:qualifiedValueShape [
                sh:datatype xsd:date ;
            ] ;
            sh:qualifiedMinCount 1 ;
            sh:message "Each instant must have at least one timestamp (either 'occp:hasActualTime' or 'occp:hasEstimatedTime') of type xsd:date."@en ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path occp:hasActualTime ;
            sh:datatype xsd:date ;
            sh:maxCount 1 ;
            sh:message "Each instant must have at most one actual timestamp via occp:hasActualTime of type xsd:date."@en ;
            sh:severity sh:Violation ;
        ] .


### CYCLE RELATED SHACL RULES

    osh:CycleShape a sh:NodeShape ;
        sh:targetClass occp:Cycle ;
        # Constraint for hasCycleNumber
        sh:property [
            sh:path occp:hasCycleNumber ;
            sh:datatype xsd:integer ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:minInclusive 1 ;
            sh:message "Each 'occp:Cycle' must specify exactly one positive integer via 'occp:hasCycleNumber' to indicate the number of iterations."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class time:Instant ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:Cycle' must have exactly one 'occp:hasActualBeginning' referencing a 'time:Instant' to mark its start."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for end (at least one end: actual or estimated, but max 1 actualEnd)
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:Cycle' must have at most one 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] ;
        sh:or (
            [ sh:property [ sh:path occp:hasActualEnd ; sh:minCount 1 ; sh:class time:Instant ] ]
            [ sh:property [ sh:path occp:hasEstimatedEnd ; sh:minCount 1 ; sh:class time:Instant ] ]
        ) ;
        sh:message "Each 'occp:Cycle' must have at least one end (either 'occp:hasActualEnd' or 'occp:hasEstimatedEnd') referencing a 'time:Instant'."@en ;
        sh:severity sh:Violation .

    osh:CycleAShape a sh:NodeShape ;
        sh:targetClass occp:CycleA_PlanningReview ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:ReviewStart ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:CycleA_PlanningReview' must have exactly one actual beginning via 'occp:hasActualBeginning' referencing 'occp:ReviewStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for end (at least one end: actual or estimated, restricted to ReviewApproval or ReviewRejection, max 1 actualEnd)
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:or (
                [ sh:class occp:ReviewApproval ]
                [ sh:class occp:ReviewRejection ]
            ) ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:CycleA_PlanningReview' must have at most one 'occp:hasActualEnd' referencing 'occp:ReviewApproval' or 'occp:ReviewRejection'."@en ;
            sh:severity sh:Violation
        ] ;
        sh:or (
            [ sh:property [ 
                sh:path occp:hasActualEnd ; 
                sh:or (
                    [ sh:class occp:ReviewApproval ]
                    [ sh:class occp:ReviewRejection ]
                ) 
            ] ]
            [ sh:property [ 
                sh:path occp:hasEstimatedEnd ; 
                sh:or (
                    [ sh:class occp:ReviewApproval ]
                    [ sh:class occp:ReviewRejection ]
                ) 
            ] ]
        ) ;
        sh:minCount 1 ;
        sh:message "Each 'occp:CycleA_PlanningReview' must have at least one end (either 'occp:hasActualEnd' or 'occp:hasEstimatedEnd') referencing 'occp:ReviewApproval' or 'occp:ReviewRejection'."@en ;
        sh:severity sh:Violation .

    osh:LifeCycleShape a sh:NodeShape ;
        sh:targetClass occp:LifeCycle ;
        # Constraint for hasLifeCycleID
        sh:property [
            sh:path occp:hasLifeCycleID ;
            sh:datatype xsd:string ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:LifeCycle' must have exactly one 'occp:hasLifeCycleID' of type xsd:string to provide a unique identifier."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for isInPhase
        sh:property [
            sh:path occp:isInPhase ;
            sh:class occp:Phase ;
            sh:minCount 1 ;
            sh:message "Each 'occp:LifeCycle' must be embedded in at least one 'occp:Phase' via 'occp:isInPhase'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for beginning (at least one: actual or estimated, max 1 actualBeginning)
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:LifeCycle' must have at most one 'occp:hasActualBeginning' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] ;
        sh:or (
            [ sh:property [ sh:path occp:hasActualBeginning ; sh:minCount 1 ; sh:class time:Instant ] ]
            [ sh:property [ sh:path occp:hasEstimatedBeginning ; sh:minCount 1 ; sh:class time:Instant ] ]
        ) ;
        sh:message "Each 'occp:LifeCycle' must have at least one beginning (either 'occp:hasActualBeginning' or 'occp:hasEstimatedBeginning') referencing a 'time:Instant'."@en ;
        sh:severity sh:Violation ;
        # Constraint for end (at least one: actual or estimated, max 1 actualEnd)
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:LifeCycle' must have at most one 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] ;
        sh:or (
            [ sh:property [ sh:path occp:hasActualEnd ; sh:minCount 1 ; sh:class time:Instant ] ]
            [ sh:property [ sh:path occp:hasEstimatedEnd ; sh:minCount 1 ; sh:class time:Instant ] ]
        ) ;
        sh:message "Each 'occp:LifeCycle' must have at least one end (either 'occp:hasActualEnd' or 'occp:hasEstimatedEnd') referencing a 'time:Instant'."@en ;
        sh:severity sh:Violation ;
        # Constraint to ensure LifeCycle times are within the embedding Phase's times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phase ?startLC ?endLC ?startPhase ?endPhase
                WHERE {
                    # Get LifeCycle start time (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstLC . 
                    ?startInstLC occp:hasActualTime ?startLC . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstLC . 
                    ?startInstLC occp:hasEstimatedTime ?startLC . }
                    # Get LifeCycle end time (actual or estimated)
                    { $this occp:hasActualEnd ?endInstLC . 
                    ?endInstLC occp:hasActualTime ?endLC . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstLC . 
                    ?endInstLC occp:hasEstimatedTime ?endLC . }
                    # Get embedding Phase
                    $this occp:isInPhase ?phase .
                    # Get Phase start time (actual or estimated)
                    { ?phase occp:hasActualBeginning ?startInstPhase . 
                    ?startInstPhase occp:hasActualTime ?startPhase . }
                    UNION
                    { ?phase occp:hasEstimatedBeginning ?startInstPhase . 
                    ?startInstPhase occp:hasEstimatedTime ?startPhase . }
                    # Get Phase end time (actual or estimated)
                    { ?phase occp:hasActualEnd ?endInstPhase . 
                    ?endInstPhase occp:hasActualTime ?endPhase . }
                    UNION
                    { ?phase occp:hasEstimatedEnd ?endInstPhase . 
                    ?endInstPhase occp:hasEstimatedTime ?endPhase . }
                    # Check conditions: startLC >= startPhase and endLC <= endPhase
                    FILTER (?startLC < ?startPhase || ?endLC > ?endPhase)
                }
            """ ;
            sh:message "Each 'occp:LifeCycle' { $this } (start: { ?startLC }, end: { ?endLC }) must have its beginning after or equal to the beginning of its embedding phase { ?phase } (start: { ?startPhase }) and its end before or equal to the end of the phase (end: { ?endPhase })."@en ;
            sh:severity sh:Violation
        ] .

### PHASE RELATED SHACL RULES

    osh:ShapeOfPhaseA a sh:NodeShape ;
        sh:targetClass occp:PhaseA_Planning ;
        # Ensure PhaseA begins before PhaseB_Review based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseB ?startA ?startB
                WHERE {
                    # Get start time of PhaseA (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantA . 
                    ?startInstantA occp:hasActualTime ?startA . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantA . 
                    ?startInstantA occp:hasEstimatedTime ?startA . }
                    # Get start time of PhaseB (actual or estimated)
                    ?phaseB a occp:PhaseB_Review .
                    { ?phaseB occp:hasActualBeginning ?startInstantB . 
                    ?startInstantB occp:hasActualTime ?startB . }
                    UNION
                    { ?phaseB occp:hasEstimatedBeginning ?startInstantB . 
                    ?startInstantB occp:hasEstimatedTime ?startB . }
                    FILTER (?startA >= ?startB)
                }
            """ ;
            sh:message "PhaseA_Planning { $this } (start: { ?startA }) must begin before PhaseB_Review { ?phaseB } (start: { ?startB })."@en ;
            sh:severity sh:Violation
        ] ;
        # Ensure PhaseA begins before PhaseC_Construction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?startA ?startC
                WHERE {
                    # Get start time of PhaseA (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantA . 
                    ?startInstantA occp:hasActualTime ?startA . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantA . 
                    ?startInstantA occp:hasEstimatedTime ?startA . }
                    # Get start time of PhaseC (actual or estimated)
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?startA >= ?startC)
                }
            """ ;
            sh:message "PhaseA_Planning { $this } (start: { ?startA }) must begin before PhaseC_Construction { ?phaseC } (start: { ?startC })."@en ;
            sh:severity sh:Violation
        ] ;
        # Ensure PhaseA ends before PhaseC_Construction begins based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?endA ?startC
                WHERE {
                    # Get end time of PhaseA (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantA . 
                    ?endInstantA occp:hasActualTime ?endA . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantA . 
                    ?endInstantA occp:hasEstimatedTime ?endA . }
                    # Get start time of PhaseC (actual or estimated)
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?endA >= ?startC)
                }
            """ ;
            sh:message "PhaseA_Planning { $this } (end: { ?endA }) must end before PhaseC_Construction { ?phaseC } begins (start: { ?startC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseA ends before CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?endA ?timeC
                WHERE {
                    # Get end time of PhaseA (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantA . 
                    ?endInstantA occp:hasActualTime ?endA . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantA . 
                    ?endInstantA occp:hasEstimatedTime ?endA . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completion a occp:CompletionOfConstruction .
                    { ?completion occp:hasActualTime ?timeC . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeC . }
                    FILTER (?endA >= ?timeC)
                }
            """ ;
            sh:message "PhaseA_Planning { $this } (end: { ?endA }) must end before CompletionOfConstruction { ?completion } (time: { ?timeC })."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:BeginningOfPlanning ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseA_Planning' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:BeginningOfPlanning'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:or (
                [ sh:class occp:ReviewApproval ]
                [ sh:class occp:CompletionOfPlanning ]
            ) ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseA_Planning' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:ReviewApproval' or 'occp:CompletionOfPlanning'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseB a sh:NodeShape ;
        sh:targetClass occp:PhaseB_Review ;
        # Ensure PhaseB begins before PhaseC_Construction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?startB ?startC
                WHERE {
                    { $this occp:hasActualBeginning ?startInstantB . 
                    ?startInstantB occp:hasActualTime ?startB . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantB . 
                    ?startInstantB occp:hasEstimatedTime ?startB . }
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?startB >= ?startC)
                }
            """ ;
            sh:message "PhaseB_Review { $this } (start: { ?startB }) must begin before PhaseC_Construction { ?phaseC } (start: { ?startC })."@en ;
            sh:severity sh:Violation
        ] ;
        # Ensure PhaseB occurs entirely before PhaseC_Construction (endB < startC) based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?endB ?startC
                WHERE {
                    { $this occp:hasActualEnd ?endInstantB . 
                    ?endInstantB occp:hasActualTime ?endB . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantB . 
                    ?endInstantB occp:hasEstimatedTime ?endB . }
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?endB >= ?startC)
                }
            """ ;
            sh:message "PhaseB_Review { $this } (end: { ?endB }) must end before PhaseC_Construction { ?phaseC } begins (start: { ?startC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseB ends before or with CompletionOfPlanning based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?endB ?timeCOP
                WHERE {
                    { $this occp:hasActualEnd ?endInstantB . 
                    ?endInstantB occp:hasActualTime ?endB . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantB . 
                    ?endInstantB occp:hasEstimatedTime ?endB . }
                    ?completion a occp:CompletionOfPlanning .
                    { ?completion occp:hasActualTime ?timeCOP . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeCOP . }
                    FILTER (?endB > ?timeCOP)
                }
            """ ;
            sh:message "PhaseB_Review { $this } (end: { ?endB }) must end before or with CompletionOfPlanning { ?completion } (time: { ?timeCOP })."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:SubmissionToReview ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseB_Review' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:SubmissionToReview'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:or (
                [ sh:class occp:ReviewApproval ]
                [ sh:class occp:CompletionOfPlanning ]
            ) ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseB_Review' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:ReviewApproval' or 'occp:CompletionOfPlanning'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfTransitionA a sh:NodeShape ;         # Transition A (Completion of Planning)
        sh:targetClass occp:CompletionOfPlanning ;
        # Ensure CompletionOfPlanning occurs before BeginOfTenderingProcess based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?beginTender ?timeCOP ?startTender
                WHERE {
                    # Get time of CompletionOfPlanning (actual or estimated)
                    { $this occp:hasActualTime ?timeCOP . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOP . }
                    # Get start time of BeginOfTenderingProcess (actual or estimated)
                    ?beginTender a occp:BeginOfTenderingProcess .
                    { ?beginTender occp:hasActualTime ?startTender . }
                    UNION
                    { ?beginTender occp:hasEstimatedTime ?startTender . }
                    FILTER (?timeCOP >= ?startTender)
                }
            """ ;
            sh:message "CompletionOfPlanning { $this } (time: { ?timeCOP }) should occur before BeginOfTenderingProcess { ?beginTender } (time: { ?startTender })."@en ;
            sh:severity sh:Warning
        ] .

    osh:ShapeOfTransitionB a sh:NodeShape ;         # Transition B (Begin Of Tendering Process)
        sh:targetClass occp:BeginOfTenderingProcess ;
        # Ensure BeginOfTenderingProcess occurs before Submission based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?submission ?startTender ?timeSub
                WHERE {
                    # Get time of BeginOfTenderingProcess (actual or estimated)
                    { $this occp:hasActualTime ?startTender . }
                    UNION
                    { $this occp:hasEstimatedTime ?startTender . }
                    # Get time of Submission (actual or estimated)
                    ?submission a occp:Submission .
                    { ?submission occp:hasActualTime ?timeSub . }
                    UNION
                    { ?submission occp:hasEstimatedTime ?timeSub . }
                    FILTER (?startTender >= ?timeSub)
                }
            """ ;
            sh:message "BeginOfTenderingProcess { $this } (time: { ?startTender }) should occur before Submission { ?submission } (time: { ?timeSub })."@en ;
            sh:severity sh:Warning
        ] .
    osh:ShapeOfTransitionC a sh:NodeShape ;         # Transition C (Submission)
        sh:targetClass occp:Submission ;
        # Ensure Submission occurs before PhaseC_Construction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?timeSub ?startC
                WHERE {
                    # Get time of Submission (actual or estimated)
                    { $this occp:hasActualTime ?timeSub . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeSub . }
                    # Get start time of PhaseC_Construction (actual or estimated)
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?timeSub >= ?startC)
                }
            """ ;
            sh:message "Submission { $this } (time: { ?timeSub }) should occur before PhaseC_Construction { ?phaseC } (start: { ?startC })."@en ;
            sh:severity sh:Warning
        ] .

    osh:ShapeOfPhaseC a sh:NodeShape ;              # Phase C (Construction)
        sh:targetClass occp:PhaseC_Construction ;
        # Ensure PhaseC occurs after CompletionOfPlanning (startC > timeCOP) based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?startC ?timeCOP
                WHERE {
                    # Get start time of PhaseC (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    # Get time of CompletionOfPlanning (actual or estimated)
                    ?completion a occp:CompletionOfPlanning .
                    { ?completion occp:hasActualTime ?timeCOP . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeCOP . }
                    FILTER (?startC <= ?timeCOP)
                }
            """ ;
            sh:message "PhaseC_Construction { $this } (start: { ?startC }) should occur after CompletionOfPlanning { ?completion } (time: { ?timeCOP })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseC occurs after Submission (startC > timeSub) based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?submission ?startC ?timeSub
                WHERE {
                    # Get start time of PhaseC (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    # Get time of Submission (actual or estimated)
                    ?submission a occp:Submission .
                    { ?submission occp:hasActualTime ?timeSub . }
                    UNION
                    { ?submission occp:hasEstimatedTime ?timeSub . }
                    FILTER (?startC <= ?timeSub)
                }
            """ ;
            sh:message "PhaseC_Construction { $this } (start: { ?startC }) should occur after Submission { ?submission } (time: { ?timeSub })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:ConstructionStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseC_Construction' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:ConstructionStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:or (
                [ sh:class occp:ConstructionAcceptance ]
                [ sh:class occp:CompletionOfConstruction ]
            ) ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseC_Construction' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:ConstructionAcceptance' or 'occp:CompletionOfConstruction'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfTransitionD a sh:NodeShape ;         # Transition D (Completion Of Construction)
        sh:targetClass occp:CompletionOfConstruction ;
        # Ensure CompletionOfConstruction occurs after CompletionOfPlanning based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completionPlanning ?timeCOC ?timeCOP
                WHERE {
                    # Get time of CompletionOfConstruction (actual or estimated)
                    { $this occp:hasActualTime ?timeCOC . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOC . }
                    # Get time of CompletionOfPlanning (actual or estimated)
                    ?completionPlanning a occp:CompletionOfPlanning .
                    { ?completionPlanning occp:hasActualTime ?timeCOP . }
                    UNION
                    { ?completionPlanning occp:hasEstimatedTime ?timeCOP . }
                    FILTER (?timeCOC <= ?timeCOP)
                }
            """ ;
            sh:message "CompletionOfConstruction { $this } (time: { ?timeCOC }) should occur after CompletionOfPlanning { ?completionPlanning } (time: { ?timeCOP })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure CompletionOfConstruction occurs before PhaseD_Usage based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseD ?timeCOC ?startD
                WHERE {
                    # Get time of CompletionOfConstruction (actual or estimated)
                    { $this occp:hasActualTime ?timeCOC . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOC . }
                    # Get start time of PhaseD_Usage (actual or estimated)
                    ?phaseD a occp:PhaseD_Usage .
                    { ?phaseD occp:hasActualBeginning ?startInstantD . 
                    ?startInstantD occp:hasActualTime ?startD . }
                    UNION
                    { ?phaseD occp:hasEstimatedBeginning ?startInstantD . 
                    ?startInstantD occp:hasEstimatedTime ?startD . }
                    FILTER (?timeCOC >= ?startD)
                }
            """ ;
            sh:message "CompletionOfConstruction { $this } (time: { ?timeCOC }) should occur before PhaseD_Usage { ?phaseD } (start: { ?startD })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure CompletionOfConstruction occurs before PhaseM_Deconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?timeCOC ?startM
                WHERE {
                    # Get time of CompletionOfConstruction (actual or estimated)
                    { $this occp:hasActualTime ?timeCOC . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOC . }
                    # Get start time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    FILTER (?timeCOC >= ?startM)
                }
            """ ;
            sh:message "CompletionOfConstruction { $this } (time: { ?timeCOC }) should occur before PhaseM_Deconstruction { ?phaseM } (start: { ?startM })."@en ;
            sh:severity sh:Warning
        ] .

    osh:ShapeOfPhaseD a sh:NodeShape ;              # Phase D (Usage)
        sh:targetClass occp:PhaseD_Usage ;
        # Ensure PhaseD occurs after CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completionC ?startD ?timeCOC
                WHERE {
                    # Get start time of PhaseD (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantD . 
                    ?startInstantD occp:hasActualTime ?startD . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantD . 
                    ?startInstantD occp:hasEstimatedTime ?startD . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completionC a occp:CompletionOfConstruction .
                    { ?completionC occp:hasActualTime ?timeCOC . }
                    UNION
                    { ?completionC occp:hasEstimatedTime ?timeCOC . }
                    FILTER (?startD <= ?timeCOC)
                }
            """ ;
            sh:message "PhaseD_Usage { $this } (start: { ?startD }) should occur after CompletionOfConstruction { ?completionC } (time: { ?timeCOC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseD ends before PhaseM_Deconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?endD ?startM
                WHERE {
                    # Get end time of PhaseD (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantD . 
                    ?endInstantD occp:hasActualTime ?endD . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantD . 
                    ?endInstantD occp:hasEstimatedTime ?endD . }
                    # Get start time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    FILTER (?endD >= ?startM)
                }
            """ ;
            sh:message "PhaseD_Usage { $this } (end: { ?endD }) should end before PhaseM_Deconstruction { ?phaseM } (start: { ?startM }). We don’t want anyone to get hurt, do we?"@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:UsageStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseD_Usage' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:UsageStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:UsageEnd ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseD_Usage' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:UsageEnd'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseE a sh:NodeShape ;              # Phase E (Warranty)
        sh:targetClass occp:PhaseE_Warranty ;
        # Ensure PhaseE occurs after CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?startE ?timeCOC
                WHERE {
                    # Get start time of PhaseE (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantE . 
                    ?startInstantE occp:hasActualTime ?startE . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantE . 
                    ?startInstantE occp:hasEstimatedTime ?startE . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completion a occp:CompletionOfConstruction .
                    { ?completion occp:hasActualTime ?timeCOC . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeCOC . }
                    FILTER (?startE <= ?timeCOC)
                }
            """ ;
            sh:message "PhaseE_Warranty { $this } (start: { ?startE }) should occur after CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:WarrantyStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseE_Warranty' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:WarrantyStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:WarrantyEnd ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseE_Warranty' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:WarrantyEnd'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseF a sh:NodeShape ;              # Phase F (DesignLife)
        sh:targetClass occp:PhaseF_DesignLife ;
        # Ensure PhaseF occurs after CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?startF ?timeCOC
                WHERE {
                    # Get start time of PhaseF (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantF . 
                    ?startInstantF occp:hasActualTime ?startF . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantF . 
                    ?startInstantF occp:hasEstimatedTime ?startF . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completion a occp:CompletionOfConstruction .
                    { ?completion occp:hasActualTime ?timeCOC . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeCOC . }
                    FILTER (?startF <= ?timeCOC)
                }
            """ ;
            sh:message "PhaseF_DesignLife { $this } (start: { ?startF }) should occur after CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseF begins before or with PhaseD_Usage based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseD ?startF ?startD
                WHERE {
                    # Get start time of PhaseF (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantF . 
                    ?startInstantF occp:hasActualTime ?startF . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantF . 
                    ?startInstantF occp:hasEstimatedTime ?startF . }
                    # Get start time of PhaseD_Usage (actual or estimated)
                    ?phaseD a occp:PhaseD_Usage .
                    { ?phaseD occp:hasActualBeginning ?startInstantD . 
                    ?startInstantD occp:hasActualTime ?startD . }
                    UNION
                    { ?phaseD occp:hasEstimatedBeginning ?startInstantD . 
                    ?startInstantD occp:hasEstimatedTime ?startD . }
                    FILTER (?startF > ?startD)
                }
            """ ;
            sh:message "PhaseF_DesignLife { $this } (start: { ?startF }) should begin before or with PhaseD_Usage { ?phaseD } (start: { ?startD })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseF occurs before PhaseM_Deconstruction (endF < startM) based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?endF ?startM
                WHERE {
                    # Get end time of PhaseF (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantF . 
                    ?endInstantF occp:hasActualTime ?endF . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantF . 
                    ?endInstantF occp:hasEstimatedTime ?endF . }
                    # Get start time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    FILTER (?endF >= ?startM)
                }
            """ ;
            sh:message "PhaseF_DesignLife { $this } (end: { ?endF }) should occur before PhaseM_Deconstruction { ?phaseM } (start: { ?startM })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:DesignLifeStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseF_DesignLife' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:DesignLifeStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:DesignLifeEnd ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseF_DesignLife' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:DesignLifeEnd'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseG a sh:NodeShape ;              # Phase G (Inspection)
        sh:targetClass occp:PhaseG_Inspection ;
        # Ensure PhaseG begins with or after UsageStart based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?usageStart ?startG ?timeUS
                WHERE {
                    # Get start time of PhaseG (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantG . 
                    ?startInstantG occp:hasActualTime ?startG . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantG . 
                    ?startInstantG occp:hasEstimatedTime ?startG . }
                    # Get time of UsageStart (actual or estimated)
                    ?usageStart a occp:UsageStart .
                    { ?usageStart occp:hasActualTime ?timeUS . }
                    UNION
                    { ?usageStart occp:hasEstimatedTime ?timeUS . }
                    FILTER (?startG < ?timeUS)
                }
            """ ;
            sh:message "PhaseG_Inspection { $this } (start: { ?startG }) must begin with or after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
            sh:severity sh:Violation
        ] ;
        # Ensure PhaseG occurs after CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?startG ?timeCOC
                WHERE {
                    # Get start time of PhaseG (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantG . 
                    ?startInstantG occp:hasActualTime ?startG . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantG . 
                    ?startInstantG occp:hasEstimatedTime ?startG . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completion a occp:CompletionOfConstruction .
                    { ?completion occp:hasActualTime ?timeCOC . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeCOC . }
                    FILTER (?startG <= ?timeCOC)
                }
            """ ;
            sh:message "PhaseG_Inspection { $this } (start: { ?startG }) should occur after CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseG occurs before PhaseM_Deconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?endG ?startM
                WHERE {
                    # Get end time of PhaseG (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantG . 
                    ?endInstantG occp:hasActualTime ?endG . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantG . 
                    ?endInstantG occp:hasEstimatedTime ?endG . }
                    # Get start time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    FILTER (?endG >= ?startM)
                }
            """ ;
            sh:message "PhaseG_Inspection { $this } (end: { ?endG }) should occur before PhaseM_Deconstruction { ?phaseM } (start: { ?startM })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:InspectionExecution ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseG_Inspection' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:InspectionExecution'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseG_Inspection' must have at most one actual end via 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] .


        osh:ShapeOfPhaseH a sh:NodeShape ;              # Phase H (SpecialEvents) - Special events can occur anytime, so this is to be handled like a super-phase. It can be used to describe or record events that have shaped the landscape like earthquakes in the past, but also events that occur during or after the construction's life cycle.
            sh:targetClass occp:PhaseH_SpecialEvents ;
            # Ensure each PhaseH has at least one instant to mark specific events
            sh:property [
                sh:path occp:hasInstant ;
                sh:class time:Instant ;
                sh:minCount 1 ;
                sh:message "Each 'occp:PhaseH_SpecialEvents' must have at least one instant via 'occp:hasInstant' referencing a 'time:Instant' (e.g., 'occp:GeologicalEvent', 'occp:WeatherEvent')."@en ;
                sh:severity sh:Violation
            ] ;
            # Constraint for hasActualBeginning
            sh:property [
                sh:path occp:hasActualBeginning ;
                sh:class time:Instant ;
                sh:maxCount 1 ;
                sh:message "Each 'occp:PhaseH_SpecialEvents' must have at most one actual beginning via 'occp:hasActualBeginning' referencing a 'time:Instant'."@en ;
                sh:severity sh:Violation
            ] ;
            # Constraint for hasActualEnd
            sh:property [
                sh:path occp:hasActualEnd ;
                sh:class time:Instant ;
                sh:maxCount 1 ;
                sh:message "Each 'occp:PhaseH_SpecialEvents' must have at most one actual end via 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
                sh:severity sh:Violation
            ] .

    osh:ShapeOfPhaseK a sh:NodeShape ;              # Phase K (Damage)
        sh:targetClass occp:PhaseK_Damage ;
        # Ensure PhaseK occurs after Submission based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?submission ?startK ?timeSub
                WHERE {
                    # Get start time of PhaseK (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantK . 
                    ?startInstantK occp:hasActualTime ?startK . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantK . 
                    ?startInstantK occp:hasEstimatedTime ?startK . }
                    # Get time of Submission (actual or estimated)
                    ?submission a occp:Submission .
                    { ?submission occp:hasActualTime ?timeSub . }
                    UNION
                    { ?submission occp:hasEstimatedTime ?timeSub . }
                    FILTER (?startK <= ?timeSub)
                }
            """ ;
            sh:message "PhaseK_Damage { $this } (start: { ?startK }) should occur after Submission { ?submission } (time: { ?timeSub })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseK occurs before CompletionOfDeconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completionDec ?endK ?timeCOD
                WHERE {
                    # Get end time of PhaseK (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantK . 
                    ?endInstantK occp:hasActualTime ?endK . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantK . 
                    ?endInstantK occp:hasEstimatedTime ?endK . }
                    # Get time of CompletionOfDeconstruction (actual or estimated)
                    ?completionDec a occp:CompletionOfDeconstruction .
                    { ?completionDec occp:hasActualTime ?timeCOD . }
                    UNION
                    { ?completionDec occp:hasEstimatedTime ?timeCOD . }
                    FILTER (?endK >= ?timeCOD)
                }
            """ ;
            sh:message "PhaseK_Damage { $this } (end: { ?endK }) should occur before CompletionOfDeconstruction { ?completionDec } (time: { ?timeCOD })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseK begins before PhaseL_Repair based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseL ?startK ?startL
                WHERE {
                    # Get start time of PhaseK (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantK . 
                    ?startInstantK occp:hasActualTime ?startK . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantK . 
                    ?startInstantK occp:hasEstimatedTime ?startK . }
                    # Get start time of PhaseL_Repair (actual or estimated)
                    ?phaseL a occp:PhaseL_Repair .
                    { ?phaseL occp:hasActualBeginning ?startInstantL . 
                    ?startInstantL occp:hasActualTime ?startL . }
                    UNION
                    { ?phaseL occp:hasEstimatedBeginning ?startInstantL . 
                    ?startInstantL occp:hasEstimatedTime ?startL . }
                    FILTER (?startK >= ?startL)
                }
            """ ;
            sh:message "PhaseK_Damage { $this } (start: { ?startK }) should begin before PhaseL_Repair { ?phaseL } (start: { ?startL }), but damage detection during repair is possible."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:DamageDetection ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseK_Damage' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:DamageDetection'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseK_Damage' must have at most one actual end via 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseL a sh:NodeShape ;              # Phase L (Repair)
        sh:targetClass occp:PhaseL_Repair ;
        # Ensure PhaseL ends with or after PhaseK_Damage based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseK ?endL ?endK
                WHERE {
                    # Get end time of PhaseL (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantL . 
                    ?endInstantL occp:hasActualTime ?endL . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantL . 
                    ?endInstantL occp:hasEstimatedTime ?endL . }
                    # Get end time of PhaseK_Damage (actual or estimated)
                    ?phaseK a occp:PhaseK_Damage .
                    { ?phaseK occp:hasActualEnd ?endInstantK . 
                    ?endInstantK occp:hasActualTime ?endK . }
                    UNION
                    { ?phaseK occp:hasEstimatedEnd ?endInstantK . 
                    ?endInstantK occp:hasEstimatedTime ?endK . }
                    FILTER (?endL < ?endK)
                }
            """ ;
            sh:message "PhaseL_Repair { $this } (end: { ?endL }) must end with or after PhaseK_Damage { ?phaseK } (end: { ?endK })."@en ;
            sh:severity sh:Violation
        ] ;
        # Ensure PhaseL occurs after Submission based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?submission ?startL ?timeSub
                WHERE {
                    # Get start time of PhaseL (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantL . 
                    ?startInstantL occp:hasActualTime ?startL . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantL . 
                    ?startInstantL occp:hasEstimatedTime ?startL . }
                    # Get time of Submission (actual or estimated)
                    ?submission a occp:Submission .
                    { ?submission occp:hasActualTime ?timeSub . }
                    UNION
                    { ?submission occp:hasEstimatedTime ?timeSub . }
                    FILTER (?startL <= ?timeSub)
                }
            """ ;
            sh:message "PhaseL_Repair { $this } (start: { ?startL }) should occur after Submission { ?submission } (time: { ?timeSub })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseL ends before PhaseM_Deconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?endL ?startM
                WHERE {
                    # Get end time of PhaseL (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantL . 
                    ?endInstantL occp:hasActualTime ?endL . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantL . 
                    ?endInstantL occp:hasEstimatedTime ?endL . }
                    # Get start time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    FILTER (?endL >= ?startM)
                }
            """ ;
            sh:message "PhaseL_Repair { $this } (end: { ?endL }) should end before PhaseM_Deconstruction { ?phaseM } (start: { ?startM })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:RepairStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseL_Repair' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:RepairStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:RepairCompletion ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseL_Repair' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:RepairCompletion'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseM a sh:NodeShape ;              # Phase M (Deconstruction)
        sh:targetClass occp:PhaseM_Deconstruction ;
        # Ensure PhaseM occurs after CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completionC ?startM ?timeCOC
                WHERE {
                    # Get start time of PhaseM (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completionC a occp:CompletionOfConstruction .
                    { ?completionC occp:hasActualTime ?timeCOC . }
                    UNION
                    { ?completionC occp:hasEstimatedTime ?timeCOC . }
                    FILTER (?startM <= ?timeCOC)
                }
            """ ;
            sh:message "PhaseM_Deconstruction { $this } (start: { ?startM }) should occur after CompletionOfConstruction { ?completionC } (time: { ?timeCOC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:DeconstructionStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseM_Deconstruction' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:DeconstructionStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:CompletionOfDeconstruction ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseM_Deconstruction' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:CompletionOfDeconstruction'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfTransitionE a sh:NodeShape ;         # Transition E (Completion Of Deconstruction)
        sh:targetClass occp:CompletionOfDeconstruction ;
        # Ensure CompletionOfDeconstruction occurs after or with the end of PhaseM_Deconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?timeCOD ?endM
                WHERE {
                    # Get time of CompletionOfDeconstruction (actual or estimated)
                    { $this occp:hasActualTime ?timeCOD . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOD . }
                    # Get end time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualEnd ?endInstantM . 
                    ?endInstantM occp:hasActualTime ?endM . }
                    UNION
                    { ?phaseM occp:hasEstimatedEnd ?endInstantM . 
                    ?endInstantM occp:hasEstimatedTime ?endM . }
                    FILTER (?timeCOD < ?endM)
                }
            """ ;
            sh:message "CompletionOfDeconstruction { $this } (time: { ?timeCOD }) must occur after or with the end of PhaseM_Deconstruction { ?phaseM } (end: { ?endM })."@en ;
            sh:severity sh:Violation
        ] .


### INSTANT RELATED SHACL RULES
    ### PHASE A INSTANTS
        # PHASE ASSIGNMENT

            osh:PhaseAInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseA_Instant ;
                sh:property [
                    sh:path occp:belongsToPhase ;
                    sh:class occp:PhaseA_Planning ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseA_Instant' must belong to exactly one 'occp:PhaseA_Planning' via 'occp:belongsToPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE A - PLANNING

            osh:BeginningOfPlanningShape a sh:NodeShape ;   # Instant Beginning Of Planning (Phase A - Planning)
                sh:targetClass occp:BeginningOfPlanning ;
                # Instant (Beginning Of Planning) starts a new Phase A (Planning)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseA_Planning ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:BeginningOfPlanning' must start exactly one 'occp:PhaseA_Planning' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure BeginningOfPlanning occurs before DataProcurement based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?dataProc ?timeBOP ?timeDP
                        WHERE {
                            # Get time of BeginningOfPlanning (actual or estimated)
                            { $this occp:hasActualTime ?timeBOP . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeBOP . }
                            # Get time of DataProcurement (actual or estimated)
                            ?dataProc a occp:DataProcurement .
                            { ?dataProc occp:hasActualTime ?timeDP . }
                            UNION
                            { ?dataProc occp:hasEstimatedTime ?timeDP . }
                            FILTER (?timeBOP >= ?timeDP)
                        }
                    """ ;
                    sh:message "BeginningOfPlanning { $this } (time: { ?timeBOP }) must occur before DataProcurement { ?dataProc } (time: { ?timeDP })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure BeginningOfPlanning occurs before SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeBOP ?timeSub
                        WHERE {
                            # Get time of BeginningOfPlanning (actual or estimated)
                            { $this occp:hasActualTime ?timeBOP . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeBOP . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeBOP >= ?timeSub)
                        }
                    """ ;
                    sh:message "BeginningOfPlanning { $this } (time: { ?timeBOP }) should occur before SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Warning
                ] .

            osh:DataProcurementShape a sh:NodeShape ;       # Instant Data Procurement (Phase A - Planning)
                sh:targetClass occp:DataProcurement ;
                # Ensure DataProcurement occurs after BeginningOfPlanning based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?beginPlanning ?timeDP ?timeBOP
                        WHERE {
                            # Get time of DataProcurement (actual or estimated)
                            { $this occp:hasActualTime ?timeDP . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDP . }
                            # Get time of BeginningOfPlanning (actual or estimated)
                            ?beginPlanning a occp:BeginningOfPlanning .
                            { ?beginPlanning occp:hasActualTime ?timeBOP . }
                            UNION
                            { ?beginPlanning occp:hasEstimatedTime ?timeBOP . }
                            FILTER (?timeDP <= ?timeBOP)
                        }
                    """ ;
                    sh:message "DataProcurement { $this } (time: { ?timeDP }) must occur after BeginningOfPlanning { ?beginPlanning } (time: { ?timeBOP })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DataProcurement occurs before SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeDP ?timeSub
                        WHERE {
                            # Get time of DataProcurement (actual or estimated)
                            { $this occp:hasActualTime ?timeDP . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDP . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeDP >= ?timeSub)
                        }
                    """ ;
                    sh:message "DataProcurement { $this } (time: { ?timeDP }) should occur before SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Warning
                ] .

            osh:Edit_BSTRShape a sh:NodeShape ;             # Instant Edit Before Submission To Review (Phase A - Planning)
                sh:targetClass occp:Edit_BSTR ;
                # Ensure Edit_BSTR occurs after BeginningOfPlanning based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?beginPlanning ?timeEdit ?timeBOP
                        WHERE {
                            # Get time of Edit_BSTR (actual or estimated)
                            { $this occp:hasActualTime ?timeEdit . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeEdit . }
                            # Get time of BeginningOfPlanning (actual or estimated)
                            ?beginPlanning a occp:BeginningOfPlanning .
                            { ?beginPlanning occp:hasActualTime ?timeBOP . }
                            UNION
                            { ?beginPlanning occp:hasEstimatedTime ?timeBOP . }
                            FILTER (?timeEdit <= ?timeBOP)
                        }
                    """ ;
                    sh:message "Edit_BSTR { $this } (time: { ?timeEdit }) must occur after BeginningOfPlanning { ?beginPlanning } (time: { ?timeBOP })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure Edit_BSTR occurs before SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeEdit ?timeSub
                        WHERE {
                            # Get time of Edit_BSTR (actual or estimated)
                            { $this occp:hasActualTime ?timeEdit . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeEdit . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeEdit >= ?timeSub)
                        }
                    """ ;
                    sh:message "Edit_BSTR { $this } (time: { ?timeEdit }) must occur before SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:SubmissionToReviewShape a sh:NodeShape ;    # Instant Submission To Review (Phase A - Planning)
                sh:targetClass occp:SubmissionToReview ;
                # Ensure SubmissionToReview occurs after Edit_BSTR or Edit_ASTR based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?editEvent ?timeSub ?timeEdit
                        WHERE {
                            # Get time of SubmissionToReview (actual or estimated)
                            { $this occp:hasActualTime ?timeSub . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeSub . }
                            # Get time of Edit_BSTR or Edit_ASTR (actual or estimated)
                            ?editEvent a ?editClass .
                            FILTER (?editClass IN (occp:Edit_BSTR, occp:Edit_ASTR))
                            { ?editEvent occp:hasActualTime ?timeEdit . }
                            UNION
                            { ?editEvent occp:hasEstimatedTime ?timeEdit . }
                            FILTER (?timeSub <= ?timeEdit)
                        }
                    """ ;
                    sh:message "SubmissionToReview { $this } (time: { ?timeSub }) must occur after Edit_BSTR or Edit_ASTR { ?editEvent } (time: { ?timeEdit })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:Edit_ASTRShape a sh:NodeShape ;             # Instant Edit After Submission To Review (Phase A - Planning)
                sh:targetClass occp:Edit_ASTR ;
                # Ensure Edit_ASTR occurs after SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeEdit ?timeSub
                        WHERE {
                            # Get time of Edit_ASTR (actual or estimated)
                            { $this occp:hasActualTime ?timeEdit . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeEdit . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeEdit <= ?timeSub)
                        }
                    """ ;
                    sh:message "Edit_ASTR { $this } (time: { ?timeEdit }) must occur after SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure Edit_ASTR occurs before CompletionOfPlanning based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeEdit ?timeCOP
                        WHERE {
                            # Get time of Edit_ASTR (actual or estimated)
                            { $this occp:hasActualTime ?timeEdit . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeEdit . }
                            # Get time of CompletionOfPlanning (actual or estimated)
                            ?completion a occp:CompletionOfPlanning .
                            { ?completion occp:hasActualTime ?timeCOP . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCOP . }
                            FILTER (?timeEdit >= ?timeCOP)
                        }
                    """ ;
                    sh:message "Edit_ASTR { $this } (time: { ?timeEdit }) should occur before CompletionOfPlanning { ?completion } (time: { ?timeCOP })."@en ;
                    sh:severity sh:Warning
                ] .


    ### PHASE B INSTANTS
        # PHASE ASSIGNMENT        
        
            osh:PhaseBInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseB_Instant ;
                sh:property [
                    sh:path occp:belongsToPhase ;
                    sh:class occp:PhaseB_Review ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseB_Instant' must belong to exactly one 'occp:PhaseB_Review' via 'occp:belongsToPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE B - REVIEW

            osh:ReviewStartShape a sh:NodeShape ;           # Instant Review Start (Phase B - Review)
                sh:targetClass occp:ReviewStart ;
                # Instant (Review Start) starts a new Phase B (Review)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseB_Review ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewStart' must start exactly one 'occp:PhaseB_Review' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Instant starts a CycleA_PlanningReview
                sh:property [
                    sh:path occp:startsCycle ;
                    sh:class occp:CycleA_PlanningReview ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewStart' must start exactly one 'occp:CycleA_PlanningReview' via 'occp:startsCycle'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ReviewStart occurs before ReviewApproval based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?reviewApproval ?timeRS ?timeRA
                        WHERE {
                            # Get time of ReviewStart (actual or estimated)
                            { $this occp:hasActualTime ?timeRS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRS . }
                            # Get time of ReviewApproval (actual or estimated)
                            ?reviewApproval a occp:ReviewApproval .
                            { ?reviewApproval occp:hasActualTime ?timeRA . }
                            UNION
                            { ?reviewApproval occp:hasEstimatedTime ?timeRA . }
                            FILTER (?timeRS >= ?timeRA)
                        }
                    """ ;
                    sh:message "ReviewStart { $this } (time: { ?timeRS }) must occur before ReviewApproval { ?reviewApproval } (time: { ?timeRA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ReviewStart occurs before ReviewRejection based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?reviewRejection ?timeRS ?timeRR
                        WHERE {
                            # Get time of ReviewStart (actual or estimated)
                            { $this occp:hasActualTime ?timeRS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRS . }
                            # Get time of ReviewRejection (actual or estimated)
                            ?reviewRejection a occp:ReviewRejection .
                            { ?reviewRejection occp:hasActualTime ?timeRR . }
                            UNION
                            { ?reviewRejection occp:hasEstimatedTime ?timeRR . }
                            FILTER (?timeRS >= ?timeRR)
                        }
                    """ ;
                    sh:message "ReviewStart { $this } (time: { ?timeRS }) must occur before ReviewRejection { ?reviewRejection } (time: { ?timeRR })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ReviewStart occurs after SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeRS ?timeSub
                        WHERE {
                            # Get time of ReviewStart (actual or estimated)
                            { $this occp:hasActualTime ?timeRS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRS . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeRS <= ?timeSub)
                        }
                    """ ;
                    sh:message "ReviewStart { $this } (time: { ?timeRS }) must occur after SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:ReviewApprovalShape a sh:NodeShape ;
                sh:targetClass occp:ReviewApproval ;
                # Optional: endsPhase for PhaseA_Planning if it exists, max 1
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?phaseA ?timeRA ?startA
                        WHERE {
                            ?phaseA a occp:PhaseA_Planning .
                            $this occp:endsPhase ?phaseA .
                            # Get time of ReviewApproval (actual or estimated)
                            { $this occp:hasActualTime ?timeRA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRA . }
                            # Get start time of PhaseA (actual or estimated)
                            { ?phaseA occp:hasActualBeginning ?startInstA . 
                            ?startInstA occp:hasActualTime ?startA . }
                            UNION
                            { ?phaseA occp:hasEstimatedBeginning ?startInstA . 
                            ?startInstA occp:hasEstimatedTime ?startA . }
                            FILTER (?timeRA <= ?startA)
                        }
                    """ ;
                    sh:message "ReviewApproval { $this } (time: { ?timeRA }) must occur after the start of PhaseA_Planning { ?phaseA } (start: { ?startA })."@en ;
                    sh:severity sh:Violation
                ] ;
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseA_Planning ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewApproval' must end at most one 'occp:PhaseA_Planning' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Optional: endsPhase for PhaseB_Review if it exists, max 1
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?phaseB ?timeRA ?startB
                        WHERE {
                            ?phaseB a occp:PhaseB_Review .
                            $this occp:endsPhase ?phaseB .
                            # Get time of ReviewApproval (actual or estimated)
                            { $this occp:hasActualTime ?timeRA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRA . }
                            # Get start time of PhaseB (actual or estimated)
                            { ?phaseB occp:hasActualBeginning ?startInstB . 
                            ?startInstB occp:hasActualTime ?startB . }
                            UNION
                            { ?phaseB occp:hasEstimatedBeginning ?startInstB . 
                            ?startInstB occp:hasEstimatedTime ?startB . }
                            FILTER (?timeRA <= ?startB)
                        }
                    """ ;
                    sh:message "ReviewApproval { $this } (time: { ?timeRA }) must occur after the start of PhaseB_Review { ?phaseB } (start: { ?startB })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Optional: endsCycle for CycleA_PlanningReview if it exists, max 1
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?cycleA ?timeRA ?startA
                        WHERE {
                            ?cycleA a occp:CycleA_PlanningReview .
                            $this occp:endsCycle ?cycleA .
                            # Get time of ReviewApproval (actual or estimated)
                            { $this occp:hasActualTime ?timeRA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRA . }
                            # Get start time of CycleA (actual or estimated)
                            { ?cycleA occp:hasActualBeginning ?startInstA . 
                            ?startInstA occp:hasActualTime ?startA . }
                            UNION
                            { ?cycleA occp:hasEstimatedBeginning ?startInstA . 
                            ?startInstA occp:hasEstimatedTime ?startA . }
                            FILTER (?timeRA <= ?startA)
                        }
                    """ ;
                    sh:message "ReviewApproval { $this } (time: { ?timeRA }) must occur after the start of CycleA_PlanningReview { ?cycleA } (start: { ?startA })."@en ;
                    sh:severity sh:Violation
                ] ;
                sh:property [
                    sh:path occp:endsCycle ;
                    sh:class occp:CycleA_PlanningReview ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewApproval' must end at most one 'occp:CycleA_PlanningReview' via 'occp:endsCycle'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ReviewApproval occurs after ReviewStart if it exists
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?reviewStart ?timeRA ?timeRS
                        WHERE {
                            # Get time of ReviewApproval (actual or estimated)
                            { $this occp:hasActualTime ?timeRA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRA . }
                            # Get time of ReviewStart (actual or estimated)
                            ?reviewStart a occp:ReviewStart .
                            { ?reviewStart occp:hasActualTime ?timeRS . }
                            UNION
                            { ?reviewStart occp:hasEstimatedTime ?timeRS . }
                            FILTER (?timeRA <= ?timeRS)
                        }
                    """ ;
                    sh:message "ReviewApproval { $this } (time: { ?timeRA }) must occur after ReviewStart { ?reviewStart } (time: { ?timeRS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:ReviewRejectionShape a sh:NodeShape ;       # Instant Review Rejection (Phase B - Review)
                sh:targetClass occp:ReviewRejection ;
                # Ensure ReviewRejection occurs after ReviewStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?reviewStart ?timeRR ?timeRS
                        WHERE {
                            # Get time of ReviewRejection (actual or estimated)
                            { $this occp:hasActualTime ?timeRR . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRR . }
                            # Get time of ReviewStart (actual or estimated)
                            ?reviewStart a occp:ReviewStart .
                            { ?reviewStart occp:hasActualTime ?timeRS . }
                            UNION
                            { ?reviewStart occp:hasEstimatedTime ?timeRS . }
                            FILTER (?timeRR <= ?timeRS)
                        }
                    """ ;
                    sh:message "ReviewRejection { $this } (time: { ?timeRR }) must occur after ReviewStart { ?reviewStart } (time: { ?timeRS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Instant (Review Rejection) ends current Cycle A (Planning/Review)
                sh:property [
                    sh:path occp:endsCycle ;
                    sh:class occp:CycleA_PlanningReview ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewRejection' must end exactly one 'occp:CycleA_PlanningReview' via 'occp:endsCycle'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ReviewRejection occurs after ReviewStart if it exists
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?reviewStart ?timeRA ?timeRS
                        WHERE {
                            # Get time of ReviewRejection (actual or estimated)
                            { $this occp:hasActualTime ?timeRA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRA . }
                            # Get time of ReviewStart (actual or estimated)
                            ?reviewStart a occp:ReviewStart .
                            { ?reviewStart occp:hasActualTime ?timeRS . }
                            UNION
                            { ?reviewStart occp:hasEstimatedTime ?timeRS . }
                            FILTER (?timeRA <= ?timeRS)
                        }
                    """ ;
                    sh:message "ReviewRejection { $this } (time: { ?timeRA }) must occur after ReviewStart { ?reviewStart } (time: { ?timeRS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE C INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseCInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseC_Instant ;
                sh:property [
                    sh:path occp:belongsToPhase ;
                    sh:class occp:PhaseC_Construction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseC_Instant' must belong to exactly one 'occp:PhaseC_Construction' via 'occp:belongsToPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE C - CONSTRUCTION

            osh:ConstructionStartShape a sh:NodeShape ;      # Instant Construction Start (Phase C - Construction)
                sh:targetClass occp:ConstructionStart ;
                # Instant (Construction Start) starts a new Phase C (Construction)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseC_Construction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ConstructionStart' must start exactly one 'occp:PhaseC_Construction' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionStart occurs before ConstructionCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeCS ?timeCC
                        WHERE {
                            { $this occp:hasActualTime ?timeCS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCS . }
                            ?completion a occp:ConstructionCompletion .
                            { ?completion occp:hasActualTime ?timeCC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCC . }
                            FILTER (?timeCS >= ?timeCC)
                        }
                    """ ;
                    sh:message "ConstructionStart { $this } (time: { ?timeCS }) must occur before ConstructionCompletion { ?completion } (time: { ?timeCC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionStart occurs after Submission based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeCS ?timeSub
                        WHERE {
                            { $this occp:hasActualTime ?timeCS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCS . }
                            ?submission a occp:Submission .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeCS <= ?timeSub)
                        }
                    """ ;
                    sh:message "ConstructionStart { $this } (time: { ?timeCS }) must occur after Submission { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:ConstructionCompletionShape a sh:NodeShape ; # Instant Construction Completion (Phase C - Construction)
                sh:targetClass occp:ConstructionCompletion ;
                # Ensure ConstructionCompletion occurs after ConstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?start ?timeCC ?timeCS
                        WHERE {
                            { $this occp:hasActualTime ?timeCC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCC . }
                            ?start a occp:ConstructionStart .
                            { ?start occp:hasActualTime ?timeCS . }
                            UNION
                            { ?start occp:hasEstimatedTime ?timeCS . }
                            FILTER (?timeCC <= ?timeCS)
                        }
                    """ ;
                    sh:message "ConstructionCompletion { $this } (time: { ?timeCC }) must occur after ConstructionStart { ?start } (time: { ?timeCS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionCompletion occurs before ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?acceptance ?timeCC ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeCC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCC . }
                            ?acceptance a occp:ConstructionAcceptance .
                            { ?acceptance occp:hasActualTime ?timeCA . }
                            UNION
                            { ?acceptance occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeCC >= ?timeCA)
                        }
                    """ ;
                    sh:message "ConstructionCompletion { $this } (time: { ?timeCC }) must occur before ConstructionAcceptance { ?acceptance } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionCompletion occurs before DefectElimStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?defectStart ?timeCC ?timeDES
                        WHERE {
                            { $this occp:hasActualTime ?timeCC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCC . }
                            ?defectStart a occp:DefectElimStart .
                            { ?defectStart occp:hasActualTime ?timeDES . }
                            UNION
                            { ?defectStart occp:hasEstimatedTime ?timeDES . }
                            FILTER (?timeCC >= ?timeDES)
                        }
                    """ ;
                    sh:message "ConstructionCompletion { $this } (time: { ?timeCC }) must occur before DefectElimStart { ?defectStart } (time: { ?timeDES })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DefectElimStartShape a sh:NodeShape ;        # Instant Defect Elimination Start (Phase C - Construction)
                sh:targetClass occp:DefectElimStart ;
                # Ensure DefectElimStart occurs after ConstructionCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeDES ?timeCC
                        WHERE {
                            { $this occp:hasActualTime ?timeDES . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDES . }
                            ?completion a occp:ConstructionCompletion .
                            { ?completion occp:hasActualTime ?timeCC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCC . }
                            FILTER (?timeDES <= ?timeCC)
                        }
                    """ ;
                    sh:message "DefectElimStart { $this } (time: { ?timeDES }) must occur after ConstructionCompletion { ?completion } (time: { ?timeCC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DefectElimStart occurs before DefectElimCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?defectComp ?timeDES ?timeDEC
                        WHERE {
                            { $this occp:hasActualTime ?timeDES . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDES . }
                            ?defectComp a occp:DefectElimCompletion .
                            { ?defectComp occp:hasActualTime ?timeDEC . }
                            UNION
                            { ?defectComp occp:hasEstimatedTime ?timeDEC . }
                            FILTER (?timeDES >= ?timeDEC)
                        }
                    """ ;
                    sh:message "DefectElimStart { $this } (time: { ?timeDES }) must occur before DefectElimCompletion { ?defectComp } (time: { ?timeDEC })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DefectElimCompletionShape a sh:NodeShape ;   # Instant Defect Elimination Completion (Phase C - Construction)
                sh:targetClass occp:DefectElimCompletion ;
                # Ensure DefectElimCompletion occurs after DefectElimStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?defectStart ?timeDEC ?timeDES
                        WHERE {
                            { $this occp:hasActualTime ?timeDEC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDEC . }
                            ?defectStart a occp:DefectElimStart .
                            { ?defectStart occp:hasActualTime ?timeDES . }
                            UNION
                            { ?defectStart occp:hasEstimatedTime ?timeDES . }
                            FILTER (?timeDEC <= ?timeDES)
                        }
                    """ ;
                    sh:message "DefectElimCompletion { $this } (time: { ?timeDEC }) must occur after DefectElimStart { ?defectStart } (time: { ?timeDES })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DefectElimCompletion occurs before ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?acceptance ?timeDEC ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeDEC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDEC . }
                            ?acceptance a occp:ConstructionAcceptance .
                            { ?acceptance occp:hasActualTime ?timeCA . }
                            UNION
                            { ?acceptance occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDEC >= ?timeCA)
                        }
                    """ ;
                    sh:message "DefectElimCompletion { $this } (time: { ?timeDEC }) must occur before ConstructionAcceptance { ?acceptance } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:ConstructionAcceptanceShape a sh:NodeShape ; # Instant Construction Acceptance (Phase C - Construction)
                sh:targetClass occp:ConstructionAcceptance ;
                # Instant (Construction Acceptance) ends a Construction Phase
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseC_Construction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'ConstructionAcceptance' must end exactly one 'occp:PhaseD_Usage' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionAcceptance occurs before UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeCA ?timeUS
                        WHERE {
                            { $this occp:hasActualTime ?timeCA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCA . }
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeCA >= ?timeUS)
                        }
                    """ ;
                    sh:message "ConstructionAcceptance { $this } (time: { ?timeCA }) should occur before UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Warning
                ] ;
                # Ensure ConstructionAcceptance occurs before CompletionOfConstruction based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeCA ?timeCOC
                        WHERE {
                            { $this occp:hasActualTime ?timeCA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCA . }
                            ?completion a occp:CompletionOfConstruction .
                            { ?completion occp:hasActualTime ?timeCOC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCOC . }
                            FILTER (?timeCA >= ?timeCOC)
                        }
                    """ ;
                    sh:message "ConstructionAcceptance { $this } (time: { ?timeCA }) must occur before CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionAcceptance occurs after ConstructionCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeCA ?timeCC
                        WHERE {
                            { $this occp:hasActualTime ?timeCA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCA . }
                            ?completion a occp:ConstructionCompletion .
                            { ?completion occp:hasActualTime ?timeCC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCC . }
                            FILTER (?timeCA <= ?timeCC)
                        }
                    """ ;
                    sh:message "ConstructionAcceptance { $this } (time: { ?timeCA }) must occur after ConstructionCompletion { ?completion } (time: { ?timeCC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionAcceptance occurs after DefectElimCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?defectComp ?timeCA ?timeDEC
                        WHERE {
                            { $this occp:hasActualTime ?timeCA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCA . }
                            ?defectComp a occp:DefectElimCompletion .
                            { ?defectComp occp:hasActualTime ?timeDEC . }
                            UNION
                            { ?defectComp occp:hasEstimatedTime ?timeDEC . }
                            FILTER (?timeCA <= ?timeDEC)
                        }
                    """ ;
                    sh:message "ConstructionAcceptance { $this } (time: { ?timeCA }) must occur after DefectElimCompletion { ?defectComp } (time: { ?timeDEC })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE D INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseDInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseD_Instant ;
                sh:property [
                    sh:path occp:belongsToPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseD_Instant' must belong to exactly one 'occp:PhaseD_Usage' via 'occp:belongsToPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE D - USAGE
                
            osh:UsageStartShape a sh:NodeShape ;      # Instant Usage Start (Phase D - Usage)
                sh:targetClass occp:UsageStart ;
                # Instant (Usage Start) starts a new Phase D (Usage)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:UsageStart' must start exactly one 'occp:PhaseD_Usage' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageStart occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constrAccept ?timeUS ?timeCA
                        WHERE {
                            # Get time of UsageStart (actual or estimated)
                            { $this occp:hasActualTime ?timeUS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUS . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?constrAccept a occp:ConstructionAcceptance .
                            { ?constrAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constrAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeUS <= ?timeCA)
                        }
                    """ ;
                    sh:message "UsageStart { $this } (time: { ?timeUS }) must occur after ConstructionAcceptance { ?constrAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageStart occurs before UsageEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageEnd ?timeUS ?timeUE
                        WHERE {
                            # Get time of UsageStart (actual or estimated)
                            { $this occp:hasActualTime ?timeUS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUS . }
                            # Get time of UsageEnd (actual or estimated)
                            ?usageEnd a occp:UsageEnd .
                            { ?usageEnd occp:hasActualTime ?timeUE . }
                            UNION
                            { ?usageEnd occp:hasEstimatedTime ?timeUE . }
                            FILTER (?timeUS >= ?timeUE)
                        }
                    """ ;
                    sh:message "UsageStart { $this } (time: { ?timeUS }) must occur before UsageEnd { ?usageEnd } (time: { ?timeUE })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:UsageChangeShape a sh:NodeShape ;      # Instant Usage Change (Phase D - Usage)
                sh:targetClass occp:UsageChange ;
                # The current Usage Phase is ended with a Change of Usage
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:UsageChange' must end at least one 'occp:PhaseD_Usage' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # A new Usage Phase is started with a Change of Usage
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:UsageChange' must start at least one 'occp:PhaseD_Usage' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageChange occurs after CompletionOfConstruction based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?compConstr ?timeUC ?timeCOC
                        WHERE {
                            # Get time of UsageChange (actual or estimated)
                            { $this occp:hasActualTime ?timeUC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUC . }
                            # Get time of CompletionOfConstruction (actual or estimated)
                            ?compConstr a occp:CompletionOfConstruction .
                            { ?compConstr occp:hasActualTime ?timeCOC . }
                            UNION
                            { ?compConstr occp:hasEstimatedTime ?timeCOC . }
                            FILTER (?timeUC <= ?timeCOC)
                        }
                    """ ;
                    sh:message "UsageChange { $this } (time: { ?timeUC }) must occur after CompletionOfConstruction { ?compConstr } (time: { ?timeCOC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageChange occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeUC ?timeUS
                        WHERE {
                            # Get time of UsageChange (actual or estimated)
                            { $this occp:hasActualTime ?timeUC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUC . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeUC <= ?timeUS)
                        }
                    """ ;
                    sh:message "UsageChange { $this } (time: { ?timeUC }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageChange occurs before UsageEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageEnd ?timeUC ?timeUE
                        WHERE {
                            # Get time of UsageChange (actual or estimated)
                            { $this occp:hasActualTime ?timeUC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUC . }
                            # Get time of UsageEnd (actual or estimated)
                            ?usageEnd a occp:UsageEnd .
                            { ?usageEnd occp:hasActualTime ?timeUE . }
                            UNION
                            { ?usageEnd occp:hasEstimatedTime ?timeUE . }
                            FILTER (?timeUC >= ?timeUE)
                        }
                    """ ;
                    sh:message "UsageChange { $this } (time: { ?timeUC }) must occur before UsageEnd { ?usageEnd } (time: { ?timeUE })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageChange occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeUC ?timeDS
                        WHERE {
                            # Get time of UsageChange (actual or estimated)
                            { $this occp:hasActualTime ?timeUC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUC . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeUC >= ?timeDS)
                        }
                    """ ;
                    sh:message "UsageChange { $this } (time: { ?timeUC }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:UsageEndShape a sh:NodeShape ;      # Instant Usage End (Phase D - Usage)
                sh:targetClass occp:UsageEnd ;
                # Instant (Usage End) ends a Usage Phase
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:UsageEnd' must end exactly one 'occp:PhaseD_Usage' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageEnd occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeUE ?timeUS
                        WHERE {
                            # Get time of UsageEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeUE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUE . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeUE <= ?timeUS)
                        }
                    """ ;
                    sh:message "UsageEnd { $this } (time: { ?timeUE }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageEnd occurs after UsageChange based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageChange ?timeUE ?timeUC
                        WHERE {
                            # Get time of UsageEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeUE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUE . }
                            # Get time of UsageChange (actual or estimated)
                            ?usageChange a occp:UsageChange .
                            { ?usageChange occp:hasActualTime ?timeUC . }
                            UNION
                            { ?usageChange occp:hasEstimatedTime ?timeUC . }
                            FILTER (?timeUE <= ?timeUC)
                        }
                    """ ;
                    sh:message "UsageEnd { $this } (time: { ?timeUE }) must occur after UsageChange { ?usageChange } (time: { ?timeUC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageEnd occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeUE ?timeDS
                        WHERE {
                            # Get time of UsageEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeUE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeUE >= ?timeDS)
                        }
                    """ ;
                    sh:message "UsageEnd { $this } (time: { ?timeUE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE E INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseEInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseE_Instant ;
                sh:property [
                    sh:path occp:belongsToPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseE_Instant' must belong to exactly one 'occp:PhaseE_Warranty' via 'occp:belongsToPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE E - WARRANTY
            osh:WarrantyStartShape a sh:NodeShape ;          # Instant Warranty Start (Phase E - Warranty)
                sh:targetClass occp:WarrantyStart ;
                # Instant (Warranty Start) starts a new Phase E (Warranty)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:WarrantyStart' must start exactly one 'occp:PhaseE_Warranty' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyStart occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?acceptance ?timeWS ?timeCA
                        WHERE {
                            # Get time of WarrantyStart (actual or estimated)
                            { $this occp:hasActualTime ?timeWS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWS . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?acceptance a occp:ConstructionAcceptance .
                            { ?acceptance occp:hasActualTime ?timeCA . }
                            UNION
                            { ?acceptance occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeWS <= ?timeCA)
                        }
                    """ ;
                    sh:message "WarrantyStart { $this } (time: { ?timeWS }) must occur after ConstructionAcceptance { ?acceptance } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyStart occurs before WarrantyEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?end ?timeWS ?timeWE
                        WHERE {
                            # Get time of WarrantyStart (actual or estimated)
                            { $this occp:hasActualTime ?timeWS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWS . }
                            # Get time of WarrantyEnd (actual or estimated)
                            ?end a occp:WarrantyEnd .
                            { ?end occp:hasActualTime ?timeWE . }
                            UNION
                            { ?end occp:hasEstimatedTime ?timeWE . }
                            FILTER (?timeWS >= ?timeWE)
                        }
                    """ ;
                    sh:message "WarrantyStart { $this } (time: { ?timeWS }) must occur before WarrantyEnd { ?end } (time: { ?timeWE })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:WarrantyChangeShape a sh:NodeShape ;         # Instant Warranty Change (Phase E - Warranty)
                sh:targetClass occp:WarrantyChange ;
                # The current Warranty Phase is ended with a Change of Warranty
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:WarrantyChange' must end at least one 'occp:PhaseE_Warranty' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # A new Warranty Phase is started with a Change of Warranty
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:WarrantyChange' must start at least one 'occp:PhaseE_Warranty' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyChange occurs after CompletionOfConstruction based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeWC ?timeCOC
                        WHERE {
                            # Get time of WarrantyChange (actual or estimated)
                            { $this occp:hasActualTime ?timeWC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWC . }
                            # Get time of CompletionOfConstruction (actual or estimated)
                            ?completion a occp:CompletionOfConstruction .
                            { ?completion occp:hasActualTime ?timeCOC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCOC . }
                            FILTER (?timeWC <= ?timeCOC)
                        }
                    """ ;
                    sh:message "WarrantyChange { $this } (time: { ?timeWC }) must occur after CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyChange occurs after WarrantyStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?start ?timeWC ?timeWS
                        WHERE {
                            # Get time of WarrantyChange (actual or estimated)
                            { $this occp:hasActualTime ?timeWC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWC . }
                            # Get time of WarrantyStart (actual or estimated)
                            ?start a occp:WarrantyStart .
                            { ?start occp:hasActualTime ?timeWS . }
                            UNION
                            { ?start occp:hasEstimatedTime ?timeWS . }
                            FILTER (?timeWC <= ?timeWS)
                        }
                    """ ;
                    sh:message "WarrantyChange { $this } (time: { ?timeWC }) must occur after WarrantyStart { ?start } (time: { ?timeWS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyChange occurs before WarrantyEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?end ?timeWC ?timeWE
                        WHERE {
                            # Get time of WarrantyChange (actual or estimated)
                            { $this occp:hasActualTime ?timeWC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWC . }
                            # Get time of WarrantyEnd (actual or estimated)
                            ?end a occp:WarrantyEnd .
                            { ?end occp:hasActualTime ?timeWE . }
                            UNION
                            { ?end occp:hasEstimatedTime ?timeWE . }
                            FILTER (?timeWC >= ?timeWE)
                        }
                    """ ;
                    sh:message "WarrantyChange { $this } (time: { ?timeWC }) must occur before WarrantyEnd { ?end } (time: { ?timeWE })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyChange occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeWC ?timeDS
                        WHERE {
                            # Get time of WarrantyChange (actual or estimated)
                            { $this occp:hasActualTime ?timeWC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWC . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeWC >= ?timeDS)
                        }
                    """ ;
                    sh:message "WarrantyChange { $this } (time: { ?timeWC }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:WarrantyEndShape a sh:NodeShape ;            # Instant Warranty End (Phase E - Warranty)
                sh:targetClass occp:WarrantyEnd ;
                # The current Warranty Phase is ended with Warranty End
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:WarrantyEnd' must end exactly one 'occp:PhaseE_Warranty' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyEnd occurs after WarrantyStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?start ?timeWE ?timeWS
                        WHERE {
                            # Get time of WarrantyEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of WarrantyStart (actual or estimated)
                            ?start a occp:WarrantyStart .
                            { ?start occp:hasActualTime ?timeWS . }
                            UNION
                            { ?start occp:hasEstimatedTime ?timeWS . }
                            FILTER (?timeWE <= ?timeWS)
                        }
                    """ ;
                    sh:message "WarrantyEnd { $this } (time: { ?timeWE }) must occur after WarrantyStart { ?start } (time: { ?timeWS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyEnd occurs after WarrantyChange based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?change ?timeWE ?timeWC
                        WHERE {
                            # Get time of WarrantyEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of WarrantyChange (actual or estimated)
                            ?change a occp:WarrantyChange .
                            { ?change occp:hasActualTime ?timeWC . }
                            UNION
                            { ?change occp:hasEstimatedTime ?timeWC . }
                            FILTER (?timeWE <= ?timeWC)
                        }
                    """ ;
                    sh:message "WarrantyEnd { $this } (time: { ?timeWE }) must occur after WarrantyChange { ?change } (time: { ?timeWC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyEnd occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeWE ?timeDS
                        WHERE {
                            # Get time of WarrantyEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeWE >= ?timeDS)
                        }
                    """ ;
                    sh:message "WarrantyEnd { $this } (time: { ?timeWE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE F INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseFInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseF_Instant ;
                sh:property [
                    sh:path occp:belongsToPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseF_Instant' must belong to exactly one 'occp:PhaseF_DesignLife' via 'occp:belongsToPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE F - DESIGN LIFE
            osh:DesignLifeStartShape a sh:NodeShape ;        # Instant Design Life Start (Phase F - Design Life)
                sh:targetClass occp:DesignLifeStart ;
                # Instant (Design Life Start) starts a new Phase F (Design Life)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DesignLifeStart' must start exactly one 'occp:PhaseF_DesignLife' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeStart occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeDLS ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeDLS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLS . }
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDLS <= ?timeCA)
                        }
                    """ ;
                    sh:message "DesignLifeStart { $this } (time: { ?timeDLS }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeStart occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconstStart ?timeDLS ?timeDS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLS . }
                            ?deconstStart a occp:DeconstructionStart .
                            { ?deconstStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconstStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDLS >= ?timeDS)
                        }
                    """ ;
                    sh:message "DesignLifeStart { $this } (time: { ?timeDLS }) must occur before DeconstructionStart { ?deconstStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeStart occurs before DesignLifeEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designEnd ?timeDLS ?timeDLE
                        WHERE {
                            { $this occp:hasActualTime ?timeDLS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLS . }
                            ?designEnd a occp:DesignLifeEnd .
                            { ?designEnd occp:hasActualTime ?timeDLE . }
                            UNION
                            { ?designEnd occp:hasEstimatedTime ?timeDLE . }
                            FILTER (?timeDLS >= ?timeDLE)
                        }
                    """ ;
                    sh:message "DesignLifeStart { $this } (time: { ?timeDLS }) must occur before DesignLifeEnd { ?designEnd } (time: { ?timeDLE })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DesignLifeChangeShape a sh:NodeShape ;       # Instant Design Life Change (Phase F - Design Life)
                sh:targetClass occp:DesignLifeChange ;
                # The current Design Life Phase is ended with a Change of Design Life
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:DesignLifeChange' must end at least one 'occp:PhaseF_DesignLife' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # A new Design Life Phase is started with a Change of Design Life
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:DesignLifeChange' must start at least one 'occp:PhaseF_DesignLife' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeChange occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeDLC ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeDLC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLC . }
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDLC <= ?timeCA)
                        }
                    """ ;
                    sh:message "DesignLifeChange { $this } (time: { ?timeDLC }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeChange occurs after DesignLifeStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designStart ?timeDLC ?timeDLS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLC . }
                            ?designStart a occp:DesignLifeStart .
                            { ?designStart occp:hasActualTime ?timeDLS . }
                            UNION
                            { ?designStart occp:hasEstimatedTime ?timeDLS . }
                            FILTER (?timeDLC <= ?timeDLS)
                        }
                    """ ;
                    sh:message "DesignLifeChange { $this } (time: { ?timeDLC }) must occur after DesignLifeStart { ?designStart } (time: { ?timeDLS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeChange occurs before DesignLifeEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designEnd ?timeDLC ?timeDLE
                        WHERE {
                            { $this occp:hasActualTime ?timeDLC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLC . }
                            ?designEnd a occp:DesignLifeEnd .
                            { ?designEnd occp:hasActualTime ?timeDLE . }
                            UNION
                            { ?designEnd occp:hasEstimatedTime ?timeDLE . }
                            FILTER (?timeDLC >= ?timeDLE)
                        }
                    """ ;
                    sh:message "DesignLifeChange { $this } (time: { ?timeDLC }) must occur before DesignLifeEnd { ?designEnd } (time: { ?timeDLE })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeChange occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconstStart ?timeDLC ?timeDS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLC . }
                            ?deconstStart a occp:DeconstructionStart .
                            { ?deconstStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconstStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDLC >= ?timeDS)
                        }
                    """ ;
                    sh:message "DesignLifeChange { $this } (time: { ?timeDLC }) must occur before DeconstructionStart { ?deconstStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DesignLifeEndShape a sh:NodeShape ;          # Instant Design Life End (Phase F - Design Life)
                sh:targetClass occp:DesignLifeEnd ;
                # The current Design Life Phase is ended with Design Life End
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DesignLifeEnd' must end exactly one 'occp:PhaseF_DesignLife' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeEnd occurs after DesignLifeStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designStart ?timeDLE ?timeDLS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLE . }
                            ?designStart a occp:DesignLifeStart .
                            { ?designStart occp:hasActualTime ?timeDLS . }
                            UNION
                            { ?designStart occp:hasEstimatedTime ?timeDLS . }
                            FILTER (?timeDLE <= ?timeDLS)
                        }
                    """ ;
                    sh:message "DesignLifeEnd { $this } (time: { ?timeDLE }) must occur after DesignLifeStart { ?designStart } (time: { ?timeDLS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeEnd occurs after DesignLifeChange based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designChange ?timeDLE ?timeDLC
                        WHERE {
                            { $this occp:hasActualTime ?timeDLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLE . }
                            ?designChange a occp:DesignLifeChange .
                            { ?designChange occp:hasActualTime ?timeDLC . }
                            UNION
                            { ?designChange occp:hasEstimatedTime ?timeDLC . }
                            FILTER (?timeDLE <= ?timeDLC)
                        }
                    """ ;
                    sh:message "DesignLifeEnd { $this } (time: { ?timeDLE }) must occur after DesignLifeChange { ?designChange } (time: { ?timeDLC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeEnd occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeDLE ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeDLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLE . }
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDLE <= ?timeCA)
                        }
                    """ ;
                    sh:message "DesignLifeEnd { $this } (time: { ?timeDLE }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeEnd occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconstStart ?timeDLE ?timeDS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLE . }
                            ?deconstStart a occp:DeconstructionStart .
                            { ?deconstStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconstStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDLE >= ?timeDS)
                        }
                    """ ;
                    sh:message "DesignLifeEnd { $this } (time: { ?timeDLE }) must occur before DeconstructionStart { ?deconstStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

        
    ### PHASE G INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseGInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseG_Instant ;
                sh:property [
                    sh:path occp:belongsToPhase ;
                    sh:class occp:PhaseG_Inspection ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseG_Instant' must belong to exactly one 'occp:PhaseG_Inspection' via 'occp:belongsToPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE G - INSPECTION
            osh:InspectionExecutionShape a sh:NodeShape ;    # Instant Inspection Execution (Phase G - Inspection)
                sh:targetClass occp:InspectionExecution ;
                # Ensure InspectionExecution occurs after ConstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constStart ?timeIE ?timeCS
                        WHERE {
                            # Get time of InspectionExecution (actual or estimated)
                            { $this occp:hasActualTime ?timeIE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeIE . }
                            # Get time of ConstructionStart (actual or estimated)
                            ?constStart a occp:ConstructionStart .
                            { ?constStart occp:hasActualTime ?timeCS . }
                            UNION
                            { ?constStart occp:hasEstimatedTime ?timeCS . }
                            FILTER (?timeIE <= ?timeCS)
                        }
                    """ ;
                    sh:message "InspectionExecution { $this } (time: { ?timeIE }) must occur after ConstructionStart { ?constStart } (time: { ?timeCS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure InspectionExecution occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeIE ?timeUS
                        WHERE {
                            # Get time of InspectionExecution (actual or estimated)
                            { $this occp:hasActualTime ?timeIE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeIE . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeIE <= ?timeUS)
                        }
                    """ ;
                    sh:message "InspectionExecution { $this } (time: { ?timeIE }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure InspectionExecution occurs after UsageChange based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageChange ?timeIE ?timeUC
                        WHERE {
                            # Get time of InspectionExecution (actual or estimated)
                            { $this occp:hasActualTime ?timeIE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeIE . }
                            # Get time of UsageChange (actual or estimated)
                            ?usageChange a occp:UsageChange .
                            { ?usageChange occp:hasActualTime ?timeUC . }
                            UNION
                            { ?usageChange occp:hasEstimatedTime ?timeUC . }
                            FILTER (?timeIE <= ?timeUC)
                        }
                    """ ;
                    sh:message "InspectionExecution { $this } (time: { ?timeIE }) must occur after UsageChange { ?usageChange } (time: { ?timeUC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure InspectionExecution occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeIE ?timeDS
                        WHERE {
                            # Get time of InspectionExecution (actual or estimated)
                            { $this occp:hasActualTime ?timeIE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeIE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeIE >= ?timeDS)
                        }
                    """ ;
                    sh:message "InspectionExecution { $this } (time: { ?timeIE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:IrregularInspectionShape a sh:NodeShape ;    # Instant Irregular Inspection (Phase G - Inspection)
                sh:targetClass occp:IrregularInspection ;
                # Ensure IrregularInspection occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeII ?timeUS
                        WHERE {
                            # Get time of IrregularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeII . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeII . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeII <= ?timeUS)
                        }
                    """ ;
                    sh:message "IrregularInspection { $this } (time: { ?timeII }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure IrregularInspection occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeII ?timeDS
                        WHERE {
                            # Get time of IrregularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeII . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeII . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeII >= ?timeDS)
                        }
                    """ ;
                    sh:message "IrregularInspection { $this } (time: { ?timeII }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:NextRegularInspectionShape a sh:NodeShape ;  # Instant Next Regular Inspection (Phase G - Inspection)
                sh:targetClass occp:NextRegularInspection ;
                # Ensure NextRegularInspection occurs after InspectionExecution based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?inspExec ?timeNRI ?timeIE
                        WHERE {
                            # Get time of NextRegularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeNRI . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeNRI . }
                            # Get time of InspectionExecution (actual or estimated)
                            ?inspExec a occp:InspectionExecution .
                            { ?inspExec occp:hasActualTime ?timeIE . }
                            UNION
                            { ?inspExec occp:hasEstimatedTime ?timeIE . }
                            FILTER (?timeNRI <= ?timeIE)
                        }
                    """ ;
                    sh:message "NextRegularInspection { $this } (time: { ?timeNRI }) must occur after InspectionExecution { ?inspExec } (time: { ?timeIE })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure NextRegularInspection occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeNRI ?timeUS
                        WHERE {
                            # Get time of NextRegularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeNRI . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeNRI . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeNRI <= ?timeUS)
                        }
                    """ ;
                    sh:message "NextRegularInspection { $this } (time: { ?timeNRI }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure NextRegularInspection occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeNRI ?timeDS
                        WHERE {
                            # Get time of NextRegularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeNRI . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeNRI . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeNRI >= ?timeDS)
                        }
                    """ ;
                    sh:message "NextRegularInspection { $this } (time: { ?timeNRI }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE H INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseHInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseH_Instant ;
                sh:property [
                    sh:path occp:belongsToPhase ;
                    sh:class occp:PhaseH_SpecialEvents ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseH_Instant' must belong to exactly one 'occp:PhaseH_SpecialEvents' via 'occp:belongsToPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE H - SPECIAL EVENTS
            osh:GeologicalEventShape a sh:NodeShape ;        # Instant Geological Event (Phase H - Special Events)
                sh:targetClass occp:GeologicalEvent ;
                # Ensure GeologicalEvent occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeGE ?timeCA
                        WHERE {
                            # Get time of GeologicalEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeGE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeGE . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeGE <= ?timeCA)
                        }
                    """ ;
                    sh:message "GeologicalEvent { $this } (time: { ?timeGE }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure GeologicalEvent occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeGE ?timeDS
                        WHERE {
                            # Get time of GeologicalEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeGE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeGE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeGE >= ?timeDS)
                        }
                    """ ;
                    sh:message "GeologicalEvent { $this } (time: { ?timeGE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:LoadEventShape a sh:NodeShape ;              # Instant Load Event (Phase H - Special Events)
                sh:targetClass occp:LoadEvent ;
                # Ensure LoadEvent occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeLE ?timeCA
                        WHERE {
                            # Get time of LoadEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeLE . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeLE <= ?timeCA)
                        }
                    """ ;
                    sh:message "LoadEvent { $this } (time: { ?timeLE }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure LoadEvent occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeLE ?timeDS
                        WHERE {
                            # Get time of LoadEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeLE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeLE >= ?timeDS)
                        }
                    """ ;
                    sh:message "LoadEvent { $this } (time: { ?timeLE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:WeatherEventShape a sh:NodeShape ;           # Instant Weather Event (Phase H - Special Events)
                sh:targetClass occp:WeatherEvent ;
                # Ensure WeatherEvent occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeWE ?timeCA
                        WHERE {
                            # Get time of WeatherEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeWE <= ?timeCA)
                        }
                    """ ;
                    sh:message "WeatherEvent { $this } (time: { ?timeWE }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WeatherEvent occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeWE ?timeDS
                        WHERE {
                            # Get time of WeatherEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeWE >= ?timeDS)
                        }
                    """ ;
                    sh:message "WeatherEvent { $this } (time: { ?timeWE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE K INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseKInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseK_Instant ;
                sh:property [
                    sh:path occp:belongsToPhase ;
                    sh:class occp:PhaseK_Damage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseK_Instant' must belong to exactly one 'occp:PhaseK_Damage' via 'occp:belongsToPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE K - DAMAGE
            osh:DamageDetectionShape a sh:NodeShape ;        # Instant Damage Detection (Phase K - Damage)
                sh:targetClass occp:DamageDetection ;
                # Instant (Damage Detection) starts a new Phase K (Damage)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseK_Damage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DamageDetection' must start exactly one 'occp:PhaseK_Damage' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DamageDetection occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?conAccept ?timeDD ?timeCA
                        WHERE {
                            # Get time of DamageDetection (actual or estimated)
                            { $this occp:hasActualTime ?timeDD . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDD . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?conAccept a occp:ConstructionAcceptance .
                            { ?conAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?conAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDD <= ?timeCA)
                        }
                    """ ;
                    sh:message "DamageDetection { $this } (time: { ?timeDD }) must occur after ConstructionAcceptance { ?conAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DamageDetection occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeDD ?timeDS
                        WHERE {
                            # Get time of DamageDetection (actual or estimated)
                            { $this occp:hasActualTime ?timeDD . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDD . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDD >= ?timeDS)
                        }
                    """ ;
                    sh:message "DamageDetection { $this } (time: { ?timeDD }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DamageObservationShape a sh:NodeShape ;      # Instant Damage Observation (Phase K - Damage)
                sh:targetClass occp:DamageObservation ;
                # Ensure DamageObservation occurs after DamageDetection based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?damageDetect ?timeDO ?timeDD
                        WHERE {
                            # Get time of DamageObservation (actual or estimated)
                            { $this occp:hasActualTime ?timeDO . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDO . }
                            # Get time of DamageDetection (actual or estimated)
                            ?damageDetect a occp:DamageDetection .
                            { ?damageDetect occp:hasActualTime ?timeDD . }
                            UNION
                            { ?damageDetect occp:hasEstimatedTime ?timeDD . }
                            FILTER (?timeDO <= ?timeDD)
                        }
                    """ ;
                    sh:message "DamageObservation { $this } (time: { ?timeDO }) must occur after DamageDetection { ?damageDetect } (time: { ?timeDD })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DamageObservation occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeDO ?timeDS
                        WHERE {
                            # Get time of DamageObservation (actual or estimated)
                            { $this occp:hasActualTime ?timeDO . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDO . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDO >= ?timeDS)
                        }
                    """ ;
                    sh:message "DamageObservation { $this } (time: { ?timeDO }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DamageRepairShape a sh:NodeShape ;           # Instant Damage Repair (Phase K - Damage)
                sh:targetClass occp:DamageRepair ;
                # The Damage Phase is ended with Damage Repair
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseK_Damage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DesignLifeEnd' must end exactly one 'occp:PhaseF_DesignLife' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DamageRepair occurs after DamageDetection based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?damageDetect ?timeDR ?timeDD
                        WHERE {
                            # Get time of DamageRepair (actual or estimated)
                            { $this occp:hasActualTime ?timeDR . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDR . }
                            # Get time of DamageDetection (actual or estimated)
                            ?damageDetect a occp:DamageDetection .
                            { ?damageDetect occp:hasActualTime ?timeDD . }
                            UNION
                            { ?damageDetect occp:hasEstimatedTime ?timeDD . }
                            FILTER (?timeDR <= ?timeDD)
                        }
                    """ ;
                    sh:message "DamageRepair { $this } (time: { ?timeDR }) must occur after DamageDetection { ?damageDetect } (time: { ?timeDD })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DamageRepair occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeDR ?timeDS
                        WHERE {
                            # Get time of DamageRepair (actual or estimated)
                            { $this occp:hasActualTime ?timeDR . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDR . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDR >= ?timeDS)
                        }
                    """ ;
                    sh:message "DamageRepair { $this } (time: { ?timeDR }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE L INSTANTS
        # PHASE ASSIGNMENT
        osh:NewComponentShape a sh:NodeShape ;           # Instant New Component (Phase L - Repair)
            sh:targetClass occp:NewComponent ;
            # Ensure NewComponent occurs after ConstructionCompletion based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?constComp ?timeNC ?timeCC
                    WHERE {
                        # Get time of NewComponent (actual or estimated)
                        { $this occp:hasActualTime ?timeNC . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeNC . }
                        # Get time of ConstructionCompletion (actual or estimated)
                        ?constComp a occp:ConstructionCompletion .
                        { ?constComp occp:hasActualTime ?timeCC . }
                        UNION
                        { ?constComp occp:hasEstimatedTime ?timeCC . }
                        FILTER (?timeNC <= ?timeCC)
                    }
                """ ;
                sh:message "NewComponent { $this } (time: { ?timeNC }) must occur after ConstructionCompletion { ?constComp } (time: { ?timeCC })."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure NewComponent occurs before DeconstructionStart based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?deconStart ?timeNC ?timeDS
                    WHERE {
                        # Get time of NewComponent (actual or estimated)
                        { $this occp:hasActualTime ?timeNC . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeNC . }
                        # Get time of DeconstructionStart (actual or estimated)
                        ?deconStart a occp:DeconstructionStart .
                        { ?deconStart occp:hasActualTime ?timeDS . }
                        UNION
                        { ?deconStart occp:hasEstimatedTime ?timeDS . }
                        FILTER (?timeNC >= ?timeDS)
                    }
                """ ;
                sh:message "NewComponent { $this } (time: { ?timeNC }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                sh:severity sh:Violation
            ] .

        osh:RepairStartShape a sh:NodeShape ;            # Instant Repair Start (Phase L - Repair)
            sh:targetClass occp:RepairStart ;
            # Instant (Repair Start) starts a new Phase L (Repair)
            sh:property [
                sh:path occp:startsPhase ;
                sh:class occp:PhaseL_Repair ;
                sh:minCount 1 ;
                sh:maxCount 1 ;
                sh:message "Each 'occp:RepairStart' must start exactly one 'occp:PhaseL_Repair' via 'occp:startsPhase'."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairStart occurs after DamageDetection based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?damageDet ?timeRS ?timeDD
                    WHERE {
                        # Get time of RepairStart (actual or estimated)
                        { $this occp:hasActualTime ?timeRS . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRS . }
                        # Get time of DamageDetection (actual or estimated)
                        ?damageDet a occp:DamageDetection .
                        { ?damageDet occp:hasActualTime ?timeDD . }
                        UNION
                        { ?damageDet occp:hasEstimatedTime ?timeDD . }
                        FILTER (?timeRS <= ?timeDD)
                    }
                """ ;
                sh:message "RepairStart { $this } (time: { ?timeRS }) must occur after DamageDetection { ?damageDet } (time: { ?timeDD })."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairStart occurs before RepairCompletion based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?repairComp ?timeRS ?timeRC
                    WHERE {
                        # Get time of RepairStart (actual or estimated)
                        { $this occp:hasActualTime ?timeRS . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRS . }
                        # Get time of RepairCompletion (actual or estimated)
                        ?repairComp a occp:RepairCompletion .
                        { ?repairComp occp:hasActualTime ?timeRC . }
                        UNION
                        { ?repairComp occp:hasEstimatedTime ?timeRC . }
                        FILTER (?timeRS >= ?timeRC)
                    }
                """ ;
                sh:message "RepairStart { $this } (time: { ?timeRS }) must occur before RepairCompletion { ?repairComp } (time: { ?timeRC })."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairStart occurs before DeconstructionStart based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?deconStart ?timeRS ?timeDS
                    WHERE {
                        # Get time of RepairStart (actual or estimated)
                        { $this occp:hasActualTime ?timeRS . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRS . }
                        # Get time of DeconstructionStart (actual or estimated)
                        ?deconStart a occp:DeconstructionStart .
                        { ?deconStart occp:hasActualTime ?timeDS . }
                        UNION
                        { ?deconStart occp:hasEstimatedTime ?timeDS . }
                        FILTER (?timeRS >= ?timeDS)
                    }
                """ ;
                sh:message "RepairStart { $this } (time: { ?timeRS }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                sh:severity sh:Violation
            ] .

        osh:RepairCompletionShape a sh:NodeShape ;       # Instant Repair Completion (Phase L - Repair)
            sh:targetClass occp:RepairCompletion ;
            # Instant (Repair Completion) ends a Phase L (Repair)
            sh:property [
                sh:path occp:endsPhase ;
                sh:class occp:PhaseL_Repair ;
                sh:minCount 1 ;
                sh:maxCount 1 ;
                sh:message "Each 'occp:RepairCompletion' must end exactly one 'occp:PhaseL_Repair' via 'occp:endsPhase'."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairCompletion occurs after RepairStart based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?repairStart ?timeRC ?timeRS
                    WHERE {
                        # Get time of RepairCompletion (actual or estimated)
                        { $this occp:hasActualTime ?timeRC . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRC . }
                        # Get time of RepairStart (actual or estimated)
                        ?repairStart a occp:RepairStart .
                        { ?repairStart occp:hasActualTime ?timeRS . }
                        UNION
                        { ?repairStart occp:hasEstimatedTime ?timeRS . }
                        FILTER (?timeRC <= ?timeRS)
                    }
                """ ;
                sh:message "RepairCompletion { $this } (time: { ?timeRC }) must occur after RepairStart { ?repairStart } (time: { ?timeRS })."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairCompletion occurs before DeconstructionStart based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?deconStart ?timeRC ?timeDS
                    WHERE {
                        # Get time of RepairCompletion (actual or estimated)
                        { $this occp:hasActualTime ?timeRC . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRC . }
                        # Get time of DeconstructionStart (actual or estimated)
                        ?deconStart a occp:DeconstructionStart .
                        { ?deconStart occp:hasActualTime ?timeDS . }
                        UNION
                        { ?deconStart occp:hasEstimatedTime ?timeDS . }
                        FILTER (?timeRC >= ?timeDS)
                    }
                """ ;
                sh:message "RepairCompletion { $this } (time: { ?timeRC }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                sh:severity sh:Violation
            ] .


    ### PHASE M INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseMInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseM_Instant ;
                sh:property [
                    sh:path occp:belongsToPhase ;
                    sh:class occp:PhaseM_Deconstruction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseM_Instant' must belong to exactly one 'occp:PhaseM_Deconstruction' via 'occp:belongsToPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE M - DECONSTRUCTION
            osh:DeconstructionStartShape a sh:NodeShape ;    # Instant Deconstruction Start (Phase M - Deconstruction)
                sh:targetClass occp:DeconstructionStart ;
                # Instant (Deconstruction Start) starts a new Phase M (Deconstruction)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseM_Deconstruction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DeconstructionStart' must start exactly one 'occp:PhaseM_Deconstruction' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DeconstructionStart occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?acceptance ?timeDS ?timeCA
                        WHERE {
                            # Get time of DeconstructionStart (actual or estimated)
                            { $this occp:hasActualTime ?timeDS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDS . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?acceptance a occp:ConstructionAcceptance .
                            { ?acceptance occp:hasActualTime ?timeCA . }
                            UNION
                            { ?acceptance occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDS <= ?timeCA)
                        }
                    """ ;
                    sh:message "DeconstructionStart { $this } (time: { ?timeDS }) must occur after ConstructionAcceptance { ?acceptance } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DeconstructionStart occurs before DeconstructionCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeDS ?timeDC
                        WHERE {
                            # Get time of DeconstructionStart (actual or estimated)
                            { $this occp:hasActualTime ?timeDS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDS . }
                            # Get time of DeconstructionCompletion (actual or estimated)
                            ?completion a occp:DeconstructionCompletion .
                            { ?completion occp:hasActualTime ?timeDC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeDC . }
                            FILTER (?timeDS >= ?timeDC)
                        }
                    """ ;
                    sh:message "DeconstructionStart { $this } (time: { ?timeDS }) must occur before DeconstructionCompletion { ?completion } (time: { ?timeDC })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DeconstructionCompletionShape a sh:NodeShape ;   # Instant Deconstruction Completion (Phase M - Deconstruction)
                sh:targetClass occp:DeconstructionCompletion ;
                # Instant (Deconstruction Completion) ends a Phase M (Deconstruction)
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseM_Deconstruction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DeconstructionCompletion' must end exactly one 'occp:PhaseM_Deconstruction' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DeconstructionCompletion occurs after DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?start ?timeDC ?timeDS
                        WHERE {
                            # Get time of DeconstructionCompletion (actual or estimated)
                            { $this occp:hasActualTime ?timeDC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDC . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?start a occp:DeconstructionStart .
                            { ?start occp:hasActualTime ?timeDS . }
                            UNION
                            { ?start occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDC <= ?timeDS)
                        }
                    """ ;
                    sh:message "DeconstructionCompletion { $this } (time: { ?timeDC }) must occur after DeconstructionStart { ?start } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation ] .



#################################################################
#    ADDITIONAL SPARQL Queries
#################################################################

### GENERIC TIME QUERIES

    ### occp:before
    osh:BeforeTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?other ?latestEndTime ?earliestStartTime WHERE {
                    $this occp:before ?other .
                    {
                        SELECT $this (MAX(?endTime) AS ?latestEndTime)
                        WHERE {
                            $this time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY $this
                    }
                    {
                        SELECT ?other (MIN(?startTime) AS ?earliestStartTime)
                        WHERE {
                            ?other time:hasBeginning ?startInstant .
                            ?startInstant occp:hasActualTime ?startTime .
                        }
                        GROUP BY ?other
                    }
                    FILTER (?latestEndTime >= ?earliestStartTime)
                }
            """ ;
            sh:message "The latest end of { $this } (time: { ?latestEndTime }) must be before the earliest beginning of { ?other } (time: { ?earliestStartTime }) via 'occp:before'."@en ;
            sh:severity sh:Violation
        ] .

    ### occp:after
    osh:AfterTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?other ?earliestStartTime ?latestEndTime WHERE {
                    $this occp:after ?other .
                    {
                        SELECT $this (MIN(?startTime) AS ?earliestStartTime)
                        WHERE {
                            $this time:hasBeginning ?startInstant .
                            ?startInstant occp:hasActualTime ?startTime .
                        }
                        GROUP BY $this
                    }
                    {
                        SELECT ?other (MAX(?endTime) AS ?latestEndTime)
                        WHERE {
                            ?other time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY ?other
                    }
                    FILTER (?earliestStartTime <= ?latestEndTime)
                }
            """ ;
            sh:message "The earliest beginning of { $this } (time: { ?earliestStartTime }) must be after the latest end of { ?other } (time: { ?latestEndTime }) via 'occp:after'."@en ;
            sh:severity sh:Violation
        ] .

    ### occp:beginsBefore
    osh:BeginsBeforeTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?other ?latestStartTime ?earliestStartTime WHERE {
                    $this occp:beginsBefore ?other .
                    {
                        SELECT $this (MAX(?startTime) AS ?latestStartTime)
                        WHERE {
                            $this time:hasBeginning ?startInstant .
                            ?startInstant occp:hasActualTime ?startTime .
                        }
                        GROUP BY $this
                    }
                    {
                        SELECT ?other (MIN(?startTime) AS ?earliestStartTime)
                        WHERE {
                            ?other time:hasBeginning ?startInstant .
                            ?startInstant occp:hasActualTime ?startTime .
                        }
                        GROUP BY ?other
                    }
                    FILTER (?latestStartTime >= ?earliestStartTime)
                }
            """ ;
            sh:message "The latest beginning of { $this } (time: { ?latestStartTime }) must be before the earliest beginning of { ?other } (time: { ?earliestStartTime }) via 'occp:beginsBefore'."@en ;
            sh:severity sh:Violation
        ] .

    ### occp:endsBefore
    osh:EndsBeforeTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?other ?latestEndTime ?earliestEndTime WHERE {
                    $this occp:endsBefore ?other .
                    {
                        SELECT $this (MAX(?endTime) AS ?latestEndTime)
                        WHERE {
                            $this time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY $this
                    }
                    {
                        SELECT ?other (MIN(?endTime) AS ?earliestEndTime)
                        WHERE {
                            ?other time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY ?other
                    }
                    FILTER (?latestEndTime >= ?earliestEndTime)
                }
            """ ;
            sh:message "The latest end of { $this } (time: { ?latestEndTime }) must be before the earliest end of { ?other } (time: { ?earliestEndTime }) via 'occp:endsBefore'."@en ;
            sh:severity sh:Violation
        ] .

    ### occp:endsAfter
    osh:EndsAfterTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?other ?earliestEndTime ?latestEndTime WHERE {
                    $this occp:endsAfter ?other .
                    {
                        SELECT $this (MIN(?endTime) AS ?earliestEndTime)
                        WHERE {
                            $this time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY $this
                    }
                    {
                        SELECT ?other (MAX(?endTime) AS ?latestEndTime)
                        WHERE {
                            ?other time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY ?other
                    }
                    FILTER (?earliestEndTime <= ?latestEndTime)
                }
            """ ;
            sh:message "The earliest end of { $this } (time: { ?earliestEndTime }) must be after the latest end of { ?other } (time: { ?latestEndTime }) via 'occp:endsAfter'."@en ;
            sh:severity sh:Violation
        ] .

    ### occp:beginsWith
    osh:BeginsWithTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?other ?startTimeThis ?startTimeOther WHERE {
                    $this occp:beginsWith ?other .
                    {
                        SELECT $this (MIN(?startTime) AS ?startTimeThis)
                        WHERE {
                            $this time:hasBeginning ?startInstant .
                            ?startInstant occp:hasActualTime ?startTime .
                        }
                        GROUP BY $this
                    }
                    {
                        SELECT ?other (MIN(?startTime) AS ?startTimeOther)
                        WHERE {
                            ?other time:hasBeginning ?startInstant .
                            ?startInstant occp:hasActualTime ?startTime .
                        }
                        GROUP BY ?other
                    }
                    FILTER (?startTimeThis != ?startTimeOther)
                }
            """ ;
            sh:message "The earliest beginning of { $this } (time: { ?startTimeThis }) must equal the earliest beginning of { ?other } (time: { ?startTimeOther }) via 'occp:beginsWith'."@en ;
            sh:severity sh:Violation
        ] .

    ### occp:endsWith
    osh:EndsWithTimeShape a sh:NodeShape ;
        sh:targetClass time:TemporalEntity ;
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?other ?endTimeThis ?endTimeOther WHERE {
                    $this occp:endsWith ?other .
                    {
                        SELECT $this (MAX(?endTime) AS ?endTimeThis)
                        WHERE {
                            $this time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY $this
                    }
                    {
                        SELECT ?other (MAX(?endTime) AS ?endTimeOther)
                        WHERE {
                            ?other time:hasEnd ?endInstant .
                            ?endInstant occp:hasActualTime ?endTime .
                        }
                        GROUP BY ?other
                    }
                    FILTER (?endTimeThis != ?endTimeOther)
                }
            """ ;
            sh:message "The latest end of { $this } (time: { ?endTimeThis }) must equal the latest end of { ?other } (time: { ?endTimeOther }) via 'occp:endsWith'."@en ;
            sh:severity sh:Violation
        ] .

	#################################################################
#    SHACL SHAPES
#################################################################

### GENERAL SHAPE RULES

    oush:GeneralDatePropertyShape a sh:PropertyShape ;     # All dates are in the xs-date format (YYYY-MM-DD).
        sh:path [ sh:alternativePath ( time:hasTime time:hasBeginning occp:hasActualBeginning occp:hasEstimatedBeginning time:hasEnd occp:hasActualEnd occp:hasEstimatedEnd ould:hasNewTime ould:hasPreviousTime ) ] ;
        sh:datatype xsd:date ;
        sh:message "The date must be in the format YYYY-MM-DD." ;
        sh:severity sh:Violation .


### UPDATE SHAPE RULES

    oush:UpdateShape a sh:NodeShape ;
        sh:targetClass ould:Update ;
        sh:property oush:GeneralDatePropertyShape ;  # Date format YYYY-MM-DD 
        sh:property [
            sh:path time:hasTime ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each Update must have exactly one time stamp (time:hasTime) - min./max. count = 1." ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
        sh:path ould:hasNewTime ;
        sh:datatype xsd:date ;
        sh:maxCount 1 ;
        sh:minCount 0 ;  # Optional
        sh:message "Each Update may have at most one ould:hasNewTime timestamp." ;
        sh:severity sh:Violation
        ] ;
        sh:property [
            sh:path ould:hasPreviousTime ;
            sh:datatype xsd:date ;
            sh:maxCount 1 ;
            sh:minCount 0 ;  # Optional
            sh:message "Each Update may have at most one ould:hasPreviousTime value." ;
            sh:severity sh:Violation
        ] ;
        sh:sparql [
            a sh:SPARQLConstraint ;
            sh:message "If hasNewTime is specified, hasPreviousTime must also be provided, and vice versa." ;
            sh:severity sh:Violation ;
            sh:prefixes [ sh:declare [ sh:prefix "ould" ; sh:namespace "http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#" ] ] ;
            sh:select """
                SELECT $this
                WHERE {
                    { $this ould:hasNewTime ?newTime . 
                    FILTER NOT EXISTS { $this ould:hasPreviousTime ?prevTime . } }
                    UNION
                    { $this ould:hasPreviousTime ?prevTime . 
                    FILTER NOT EXISTS { $this ould:hasNewTime ?newTime . } }
                }
            """
        ] ;
        sh:property [
            sh:path ould:hasUpdatedEvent ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each Update must reference exactly one updated event (time:instant or time:interval)." ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path ould:hasIFCID ;
            sh:minCount 0 ;
            sh:maxCount 1 ;
            sh:datatype xsd:string ;
            sh:message "Each Update can only be linked to one IFC component via ould:hasIFCID." ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path ould:hasHash ;
            sh:minCount 0 ;
            sh:maxCount 1 ;
            sh:datatype xsd:string ;
            sh:message "Each Update can be linked to at most one IFC component's hash value via ould:hasHash." ;
            sh:severity sh:Violation ;
        ] ;
        sh:sparql [
            a sh:SPARQLConstraint ;
            sh:message "hasNewTime must be later than hasPreviousTime if both exist." ;
            sh:severity sh:Violation ;
            sh:prefixes [ sh:declare [ sh:prefix "ould" ; sh:namespace "http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#" ] ] ;
            sh:select """
                SELECT $this ?prevTime ?newTime
                WHERE {
                    $this ould:hasPreviousTime ?prevTime .
                    $this ould:hasNewTime ?newTime .
                    FILTER (?newTime <= ?prevTime)
                }
            """ ;
        ] .

    oush:UpdateChainShape a sh:NodeShape ;
        sh:targetClass ould:UpdateChain ;
        sh:property [
            sh:path ould:hasNextChain ;
            sh:class ould:UpdateChain ;
            sh:maxCount 1 ;
            sh:message "Each UpdateChain may be linked to at most one next chain." ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path ould:hasPreviousChain ;
            sh:class ould:UpdateChain ;
            sh:maxCount 1 ;
            sh:message "Each UpdateChain may be linked to at most one previous chain." ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path ould:hasUpdate ;
            sh:class ould:Update ;
            sh:minCount 1 ;
            sh:maxCount 21 ;
            sh:message "Each UpdateChain must contain between 1 and 21 Updates or UpdateChainElements." ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path time:hasBeginning ;
            sh:datatype xsd:date ; 
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each UpdateChain must have a beginning in format xsd:date." ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path time:hasEnd ;
            sh:datatype xsd:date ; 
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each UpdateChain must have a End in format xsd:date." ;
            sh:severity sh:Violation ;    
        ] ;
        sh:sparql [
        a sh:SPARQLConstraint ;
        sh:message "time:hasBeginning must match the earliest time:hasTime of its Updates." ;
        sh:severity sh:Violation ;
        sh:prefixes [ sh:declare [ sh:prefix "ould" ; sh:namespace "http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#" ] ;
                      sh:declare [ sh:prefix "time" ; sh:namespace "http://www.w3.org/2006/time#" ] ] ;
        sh:select """
            SELECT $this ?begin ?earliest
            WHERE {
                $this time:hasBeginning ?begin .
                $this ould:hasUpdate ?update .
                ?update time:hasTime ?updateTime .
                {
                    SELECT $this (MIN(?time) AS ?earliest)
                    WHERE {
                        $this ould:hasUpdate ?u .
                        ?u time:hasTime ?time .
                    }
                    GROUP BY $this
                }
                FILTER (?begin != ?earliest)
            }
        """ ;
        ] ;
        sh:sparql [
            a sh:SPARQLConstraint ;
            sh:message "time:hasEnd must match the latest time:hasTime of its Updates." ;
            sh:severity sh:Violation ;
            sh:prefixes [ sh:declare [ sh:prefix "ould" ; sh:namespace "http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#" ] ;
                        sh:declare [ sh:prefix "time" ; sh:namespace "http://www.w3.org/2006/time#" ] ] ;
            sh:select """
                SELECT $this ?end ?latest
                WHERE {
                    $this time:hasEnd ?end .
                    $this ould:hasUpdate ?update .
                    ?update time:hasTime ?updateTime .
                    {
                        SELECT $this (MAX(?time) AS ?latest)
                        WHERE {
                            $this ould:hasUpdate ?u .
                            ?u time:hasTime ?time .
                        }
                        GROUP BY $this
                    }
                    FILTER (?end != ?latest)
                }
            """ ;
        ] ;
        sh:sparql [
            a sh:SPARQLConstraint ;
            sh:message "An UpdateChain must contain all Updates of its UpdatableEntity once it exists." ;
            sh:severity sh:Violation ;
            sh:prefixes [ sh:declare [ sh:prefix "ould" ; sh:namespace "http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#" ] ] ;
            sh:select """
                SELECT $this ?entity ?update
                WHERE {
                    ?entity ould:hasUpdateChain $this .
                    ?entity ould:hasUpdate ?update .
                    FILTER NOT EXISTS { $this ould:hasUpdate ?update . }
                    {
                        SELECT ?entity (COUNT(?u) AS ?updateCount)
                        WHERE {
                            ?entity ould:hasUpdate ?u .
                        }
                        GROUP BY ?entity
                        HAVING (?updateCount > 1)
                    }
                }
            """ ;
        ] .

    oush:UpdateChainContinuityConstraint a sh:NodeShape ;
        sh:targetClass ould:UpdateChain ;
        sh:sparql [
            sh:message "An UpdateChain must not contain more than 21 Updates." ;
            sh:prefixes [ sh:declare [ sh:prefix "ould" ; sh:namespace "http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#" ] ] ;
            sh:select """
                SELECT $this
                WHERE {
                    $this ould:hasUpdate ?u .
                }
                GROUP BY $this
                HAVING (COUNT(?u) > 21)
            """
        ] .

    oush:UpdateChainElementShape a sh:NodeShape ;
        sh:targetClass ould:UpdateChainElement ;
        sh:property [
            sh:path time:hasTime ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each UpdateChainElement must have exactly one time:hasTime timestamp." ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path ould:hasUpdatedEvent ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each UpdateChainElement must reference exactly one updated event (time:instant or time:interval)." ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path ould:hasIFCID ;
            sh:minCount 0 ;
            sh:maxCount 2 ;
            sh:message "Each UpdateChainElement can be linked to max. two IFC components via ould:hasIFCID." ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path ould:hasHash ;
            sh:minCount 0 ;
            sh:maxCount 2 ;
            sh:message "Each UpdateChainElement can have max. two recorded hash values via ould:hasHash." ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path ould:hasNewTime ;
            sh:datatype xsd:date ;
            sh:minCount 0 ;
            sh:maxCount 1 ;
            sh:message "Each UpdateChainElement can have at most one ould:hasNewTime timestamp in xsd:date format." ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path ould:hasPreviousTime ;
            sh:maxCount 1 ;
            sh:message "An UpdateChainElement may have at most one ould:hasPreviousTime value." ;
            sh:severity sh:Warning ;
        ] .

    oush:UpdateChainSplitConstraint a sh:NodeShape ;
        sh:targetClass ould:UpdatableEntity ;
        sh:sparql [
            a sh:SPARQLConstraint ;
            sh:message "If an UpdatableEntity has more than 21 Updates, they must be split into chains with max 21 Updates each, linked via hasNextChain. After split, the old chain must have max 20 Updates." ;
            sh:severity sh:Violation ;
            sh:prefixes [ sh:declare [ sh:prefix "ould" ; sh:namespace "http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#" ] ] ;
            sh:select """
                SELECT $this ?chain ?updateCount
                WHERE {
                    $this ould:hasUpdate ?update .
                    $this ould:hasUpdateChain ?chain .
                    {
                        SELECT $this ?chain (COUNT(?u) AS ?updateCount)
                        WHERE {
                            $this ould:hasUpdate ?u .
                            ?chain ould:hasUpdate ?u .
                        }
                        GROUP BY $this ?chain
                        HAVING (?updateCount > 21)  
                    }
                }
            """
        ] .

    oush:UpdatableEntityShape a sh:NodeShape ;
        sh:targetClass ould:UpdatableEntity ;
        sh:property [
            sh:path ould:hasIFCID ;
            sh:datatype xsd:string ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each 'ould:UpdatableEntity' must have exactly one 'ould:hasIFCID' of type xsd:string."@en ;
            sh:severity sh:Violation
        ] ;
        sh:property [
            sh:path ould:hasHash ;
            sh:datatype xsd:string ;
            sh:minCount 0 ;
            sh:maxCount 1 ;
            sh:message "Each 'ould:UpdatableEntity' can have at most one 'ould:hasHash' of type xsd:string."@en ;
            sh:severity sh:Violation
        ] .

    oush:UpdatableEntityBaselineShape a sh:NodeShape ;
        sh:targetClass ould:UpdatableEntity ;
        sh:sparql [
            a sh:SPARQLConstraint ;
            sh:message "Each UpdatableEntity must have at least one Update with a hasIFCID." ;
            sh:severity sh:Violation ;
            sh:prefixes [ sh:declare [ sh:prefix "ould" ; sh:namespace "http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#" ] ] ;
            sh:select """
                SELECT $this
                WHERE {
                    $this ould:hasUpdate ?update .
                    FILTER NOT EXISTS { ?update ould:hasIFCID ?ifcid . }
                }
            """ ;
        ] .

    oush:UpdateReplacementShape a sh:NodeShape ;
        sh:targetClass ould:UpdateReplacement ;
        sh:property oush:GeneralDatePropertyShape ;  # Date format YYYY-MM-DD 
        sh:property [
            sh:path time:hasTime ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each UpdateReplacement must have exactly one timestamp (time:hasTime)." ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path ould:hasPredecessor ;
            sh:class ould:Update ;
            sh:minCount 1 ;
            sh:message "Each UpdateReplacement must reference at least one predecessor Update via ould:hasPredecessor." ;
            sh:severity sh:Violation ;
        ] ;
        sh:property [
            sh:path ould:hasSuccessor ;
            sh:class ould:Update ;
            sh:minCount 0 ;
            sh:maxCount 1 ;
            sh:message "An UpdateReplacement may have at most one successor (e.g., ould:Update or ould:UpdateReplacement)." ;
            sh:severity sh:Violation ;
        ] .

    oush:ReplacementChronologyConstraint a sh:NodeShape ;
        sh:targetClass ould:UpdateReplacement ;
        sh:sparql [
            a sh:SPARQLConstraint ;
            sh:message "The successor UpdateReplacement must have a later timestamp than its predecessor Update." ;
            sh:severity sh:Violation ;
            sh:prefixes [ 
                sh:declare [ sh:prefix "ould" ; sh:namespace "http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#" ] ;
            ] ;
            sh:select """
                SELECT $this ?prevTime ?newTime
                WHERE {
                    $this ould:hasPredecessor ?prevUpdate .
                    ?prevUpdate time:hasTime ?prevTime .
                    $this time:hasTime ?newTime .
                    FILTER (?prevTime > ?newTime) 
                }
            """ ;
        ] .

    oush:PredecessorConstraint a sh:NodeShape ;
        sh:targetClass ould:UpdateReplacement ;
        sh:sparql [
            sh:message "Each UpdateReplacement must reference a valid predecessor Update that exists." ;
            sh:prefixes [ sh:declare [ sh:prefix "ould" ; sh:namespace "http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#" ] ] ;
            sh:select """
                SELECT $this
                WHERE {
                    $this a ould:UpdateReplacement .
                    FILTER NOT EXISTS { $this ould:hasPredecessor ?pred . }
                }
            """
        ] .

    oush:SuccessorConstraint a sh:NodeShape ;
        sh:targetSubjectsOf ould:hasSuccessor ;
        sh:property [
            sh:path ould:hasSuccessor ;
            sh:class ould:Update ;
            sh:minCount 0 ;
            sh:maxCount 1 ;
            sh:message "Each ould:Update may reference at most one successor (e.g., ould:Update or ould:UpdateReplacement)." ;
            sh:severity sh:Violation ;
        ] .

    oush:UpdateEntityShape a sh:NodeShape ;
        sh:targetSubjectsOf ould:hasUpdate ;
        sh:property [
            sh:path ould:hasUpdate ;
            sh:class ould:Update ;
            sh:minCount 1 ;
            sh:message "Each entity with an update must be linked to at least one ould:Update instance." ;
            sh:severity sh:Violation ;
        ] .

    oush:UpdatedValueShape a sh:NodeShape ;
        sh:targetClass ould:Update ;
        sh:property [
            sh:path ould:hasUpdatedValue ;
            sh:minCount 1 ;
            sh:message "Each update must reference at least one modified entity (e.g., IFC component, phase, or instant)." ;
            sh:severity sh:Violation ;
        ] .

    oush:UpdatedEventShape a sh:NodeShape ;
        sh:targetClass ould:Update ;
        sh:property [
            sh:path ould:hasUpdatedEvent ;
            sh:class <http://www.w3.org/2006/time#TemporalEntity> ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each update must be linked to exactly one modified temporal entity (e.g., phase, cycle, transition, or instant)." ;
            sh:severity sh:Violation ;
        ] .


### LINKED DATA SHAPE RULES

    oush:LinkedDataPropertyShape a sh:PropertyShape ;
        sh:path ( ould:hasOnlineData ould:hasOfflineData ) ;
        sh:or (
            [ sh:datatype xsd:anyURI ]
            [ sh:datatype xsd:string ]
        ) ;
        sh:message "Must be a URI (online) or string (offline)."@en ;
        sh:severity sh:Violation .

    oush:LinkedDataShape a sh:NodeShape ;
        sh:targetClass ould:LinkedData ;
            sh:property [
                sh:path ould:hasDataLocation ;
                sh:datatype xsd:string ;
                sh:minCount 1 ;
                sh:message "Each LinkedData must have exactly one location."@en ;
                sh:severity sh:Violation ;
            ] .


### MODEL STRUCTURE SHAPE RULES

    oush:ComponentShape a sh:NodeShape ;
        sh:targetClass ould:UpdatableEntity ;
        sh:not [
            sh:property [
                sh:path ould:consistsOf ;
                sh:minCount 1
            ]
        ] .

  oush:CompositeEntityShape a sh:NodeShape ;
      sh:targetSubjectsOf ould:consistsOf ;  
      sh:property [
          sh:path ould:consistsOf ;
          sh:minCount 1 ;
          sh:message "Each composite entity must consist of at least one component via 'ould:consistsOf'."@en ;
          sh:severity sh:Violation
      ] .
    
    oush:ComponentHierarchyShape a sh:NodeShape ;
        sh:targetClass ould:UpdatableEntity ;
        # Ensure parent phase start is the earliest of all direct component phase starts
#        sh:sparql [
#            sh:select """
#                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
#                PREFIX ould: <http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#>
#                PREFIX time: <http://www.w3.org/2006/time#>
#                SELECT $this ?parentPhase ?compPhase ?startParent ?earliestCompStart
#                WHERE {
#                    $this ould:consistsOf ?component .  # Nur direkte Kinder
#                    $this occp:hasPhase ?parentPhase .
#                    ?component occp:hasPhase ?compPhase .
#                    # Get parent phase start (actual or estimated)
#                    { ?parentPhase occp:hasActualBeginning ?startInstP . 
#                    ?startInstP occp:hasActualTime ?startParent . }
#                    UNION
#                    { ?parentPhase occp:hasEstimatedBeginning ?startInstP . 
#                    ?startInstP occp:hasEstimatedTime ?startParent . }
#                    # Get earliest direct component phase start
#                    {
#                        SELECT ?component (MIN(?startTime) AS ?earliestCompStart)
#                        WHERE {
#                            ?component occp:hasPhase ?cPhase .
#                            { ?cPhase occp:hasActualBeginning ?startInstC . 
#                            ?startInstC occp:hasActualTime ?startTime . }
#                            UNION
#                            { ?cPhase occp:hasEstimatedBeginning ?startInstC . 
#                            ?startInstC occp:hasEstimatedTime ?startTime . }
#                        }
#                        GROUP BY ?component
#                    }
#                    FILTER (?startParent > ?earliestCompStart)
#                }
#            """ ;
#            sh:message "Parent phase { ?parentPhase } (start: { ?startParent }) must start at or before the earliest direct #component phase start (start: { ?earliestCompStart })."@en ;
#            sh:severity sh:Violation
#        ] ;
#        # Ensure parent phase end is the latest of all direct component phase ends
#        sh:sparql [
#            sh:select """
#                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
#                PREFIX ould: <http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#>
#                PREFIX time: <http://www.w3.org/2006/time#>
#                SELECT $this ?parentPhase ?compPhase ?endParent ?latestCompEnd
#                WHERE {
#                    $this ould:consistsOf ?component .  # Nur direkte Kinder
#                    $this occp:hasPhase ?parentPhase .
#                    ?component occp:hasPhase ?compPhase .
#                    # Get parent phase end (actual or estimated)
#                    { ?parentPhase occp:hasActualEnd ?endInstP . 
#                    ?endInstP occp:hasActualTime ?endParent . }
#                    UNION
#                    { ?parentPhase occp:hasEstimatedEnd ?endInstP . 
#                    ?endInstP occp:hasEstimatedTime ?endParent . }
#                    # Get latest direct component phase end
#                    {
#                        SELECT ?component (MAX(?endTime) AS ?latestCompEnd)
#                       WHERE {
#                            ?component occp:hasPhase ?cPhase .
#                            { ?cPhase occp:hasActualEnd ?endInstC . 
#                            ?endInstC occp:hasActualTime ?endTime . }
#                            UNION
#                            { ?cPhase occp:hasEstimatedEnd ?endInstC . 
#                            ?endInstC occp:hasEstimatedTime ?endTime . }
#                        }
#                        GROUP BY ?component
#                    }
#                    FILTER (?endParent < ?latestCompEnd)
#                }
#            """ ;
#            sh:message "Parent phase { ?parentPhase } (end: { ?endParent }) must end at or after the latest direct component phase #end (end: { ?latestCompEnd })."@en ;
#            sh:severity sh:Violation
#        ] ;
#        # Ensure parent cycle number is the sum of max direct component cycle numbers
#        sh:sparql [
#            sh:select """
#                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
#                PREFIX ould: <http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#>
#                SELECT $this ?parentCycle ?totalCompCycles ?parentCycleNum
#                WHERE {
#                    $this ould:consistsOf ?component .  # Nur direkte Kinder
#                    $this occp:hasCycle ?parentCycle .
#                    ?parentCycle occp:hasCycleNumber ?parentCycleNum .
#                    # Calculate sum of max cycle numbers from direct components
#                    {
#                        SELECT (SUM(?maxCycleNum) AS ?totalCompCycles)
#                        WHERE {
#                            $this ould:consistsOf ?comp .
#                            ?comp occp:hasCycle ?compCycle .
#                            ?compCycle occp:hasCycleNumber ?cycleNum .
#                            {
#                                SELECT ?comp (MAX(?cycleNum) AS ?maxCycleNum)
#                                WHERE {
#                                    ?comp occp:hasCycle ?cCycle .
#                                    ?cCycle occp:hasCycleNumber ?cycleNum .
#                                }
#                                GROUP BY ?comp
#                            }
#                        }
#                    }
#                    FILTER (?parentCycleNum != ?totalCompCycles)
#                }
#            """ ;
#            sh:message "Parent cycle { ?parentCycle } (number: { ?parentCycleNum }) must equal the sum of max direct component #cycle numbers ({ ?totalCompCycles })."@en ;
#            sh:severity sh:Violation
#        ] ;
#        # Ensure CompletionOfPlanning only after all PhaseA and PhaseB of direct components are complete
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX ould: <http://www.semanticweb.org/albrechtvaatz/ontologies/2024/OULD#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?parentPhase ?compPhase ?endParent ?latestCompEnd
                WHERE {
                    $this ould:consistsOf ?component .  # Nur direkte Kinder
                    $this occp:hasPhase ?parentPhase .
                    ?parentPhase a occp:CompletionOfPlanning .
                    ?parentPhase occp:hasActualEnd ?endInstP .
                    ?endInstP occp:hasActualTime ?endParent .
                    ?component occp:hasPhase ?compPhase .
                    ?compPhase a ?compPhaseType .
                    FILTER (?compPhaseType IN (occp:PhaseA_Planning, occp:PhaseB_Review))
                    # Get latest direct component PhaseA/PhaseB end
                    {
                        SELECT ?component (MAX(?endTime) AS ?latestCompEnd)
                        WHERE {
                            ?component occp:hasPhase ?cPhase .
                            ?cPhase a ?cPhaseType .
                            FILTER (?cPhaseType IN (occp:PhaseA_Planning, occp:PhaseB_Review))
                            { ?cPhase occp:hasActualEnd ?endInstC . 
                            ?endInstC occp:hasActualTime ?endTime . }
                            UNION
                            { ?cPhase occp:hasEstimatedEnd ?endInstC . 
                            ?endInstC occp:hasEstimatedTime ?endTime . }
                        }
                        GROUP BY ?component
                    }
                    FILTER (?endParent < ?latestCompEnd)
                }
            """ ;
            sh:message "Parent phase CompletionOfPlanning { ?parentPhase } (end: { ?endParent }) must occur after all direct component PhaseA and PhaseB ends (latest: { ?latestCompEnd })."@en ;
            sh:severity sh:Violation
        ] .