@prefix sh:     <http://www.w3.org/ns/shacl#> .
@prefix xsd:    <http://www.w3.org/2001/XMLSchema#> .
@prefix occp:   <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#> .
@prefix time:   <http://www.w3.org/2006/time#> .
@prefix osh:    <http://www.occpshape.de/shape#> .

### CYCLE RELATED SHACL RULES

    osh:CycleShape a sh:NodeShape ;
        sh:targetClass occp:Cycle ;
        # Constraint for hasCycleNumber
        sh:property [
            sh:path occp:hasCycleNumber ;
            sh:datatype xsd:integer ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:minInclusive 1 ;
            sh:message "Each 'occp:Cycle' must specify exactly one positive integer via 'occp:hasCycleNumber' to indicate the number of iterations."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path time:hasActualBeginning ;
            sh:class time:Instant ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:Cycle' must have exactly one 'time:hasActualBeginning' referencing a 'time:Instant' to mark its start."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for end (at least one end: actual or estimated, but max 1 actualEnd)
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:Cycle' must have at most one 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] ;
        sh:or (
            [ sh:property [ sh:path occp:hasActualEnd ; sh:minCount 1 ; sh:class time:Instant ] ]
            [ sh:property [ sh:path occp:hasEstimatedEnd ; sh:minCount 1 ; sh:class time:Instant ] ]
        ) ;
        sh:message "Each 'occp:Cycle' must have at least one end (either 'occp:hasActualEnd' or 'occp:hasEstimatedEnd') referencing a 'time:Instant'."@en ;
        sh:severity sh:Violation .

    osh:CycleAShape a sh:NodeShape ;
        sh:targetClass occp:CycleA_PlanningReview ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:or (
                [ sh:class occp:BeginningOfPlanning ]
                [ sh:class occp:SubmissionToReview ]
            ) ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:CycleA_PlanningReview' must have exactly one actual beginning via 'occp:hasActualBeginning' referencing 'occp:SubmissionToReview' or 'occp:BeginningOfPlanning'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for end (at least one end: actual or estimated, restricted to ReviewApproval or ReviewRejection, max 1 actualEnd)
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:or (
                [ sh:class occp:ReviewApproval ]
                [ sh:class occp:ReviewRejection ]
            ) ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:CycleA_PlanningReview' must have at most one 'occp:hasActualEnd' referencing 'occp:ReviewApproval' or 'occp:ReviewRejection'."@en ;
            sh:severity sh:Violation
        ] ;
        sh:or (
            [ sh:property [ 
                sh:path occp:hasActualEnd ; 
                sh:minCount 1 ;
                sh:or (
                    [ sh:class occp:ReviewApproval ]
                    [ sh:class occp:ReviewRejection ]
                ) 
            ] ]
            [ sh:property [ 
                sh:path occp:hasEstimatedEnd ; 
                sh:minCount 1 ;
                sh:or (
                    [ sh:class occp:ReviewApproval ]
                    [ sh:class occp:ReviewRejection ]
                ) 
            ] ]
        ) ;
        sh:message "Each 'occp:CycleA_PlanningReview' must have at least one end (either 'occp:hasActualEnd' or 'occp:hasEstimatedEnd') referencing 'occp:ReviewApproval' or 'occp:ReviewRejection'."@en ;
        sh:severity sh:Violation ;
        # Constraint for isInPhase
        sh:property [
            sh:path occp:isInPhase ;
            sh:or (
                [ sh:class occp:PhaseA_Planning ]
                [ sh:class occp:PhaseB_Review ]
            ) ;
            sh:minCount 1 ;
            sh:message "Each 'occp:CycleA_PlanningReview' must be embedded in at least one 'occp:PhaseA_Planning' via 'occp:isInPhase'."@en ;
            sh:severity sh:Violation
        ] .

    osh:LifeCycleShape a sh:NodeShape ;
        sh:targetClass occp:LifeCycle ;
        # Constraint for hasLifeCycleID
        sh:property [
            sh:path occp:hasLifeCycleID ;
            sh:datatype xsd:string ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:LifeCycle' must have exactly one 'occp:hasLifeCycleID' of type xsd:string to provide a unique identifier."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for isInPhase
        sh:property [
            sh:path occp:isInPhase ;
            sh:class occp:Phase ;
            sh:minCount 1 ;
            sh:message "Each 'occp:LifeCycle' must be embedded in at least one 'occp:Phase' via 'occp:isInPhase'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for beginning (at least one: actual or estimated, max 1 actualBeginning)
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:LifeCycle' must have at most one 'occp:hasActualBeginning' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] ;
        sh:or (
            [ sh:property [ sh:path occp:hasActualBeginning ; sh:minCount 1 ; sh:class time:Instant ] ]
            [ sh:property [ sh:path occp:hasEstimatedBeginning ; sh:minCount 1 ; sh:class time:Instant ] ]
        ) ;
        sh:message "Each 'occp:LifeCycle' must have at least one beginning (either 'occp:hasActualBeginning' or 'occp:hasEstimatedBeginning') referencing a 'time:Instant'."@en ;
        sh:severity sh:Violation ;
        # Constraint for end (at least one: actual or estimated, max 1 actualEnd)
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:LifeCycle' must have at most one 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] ;
        sh:or (
            [ sh:property [ sh:path occp:hasActualEnd ; sh:minCount 1 ; sh:class time:Instant ] ]
            [ sh:property [ sh:path occp:hasEstimatedEnd ; sh:minCount 1 ; sh:class time:Instant ] ]
        ) ;
        sh:message "Each 'occp:LifeCycle' must have at least one end (either 'occp:hasActualEnd' or 'occp:hasEstimatedEnd') referencing a 'time:Instant'."@en ;
        sh:severity sh:Violation ;
        # Constraint to ensure LifeCycle times are within the embedding Phase's times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phase ?startLC ?endLC ?startPhase ?endPhase
                WHERE {
                    # Get LifeCycle start time (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstLC . 
                    ?startInstLC occp:hasActualTime ?startLC . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstLC . 
                    ?startInstLC occp:hasEstimatedTime ?startLC . }
                    # Get LifeCycle end time (actual or estimated)
                    { $this occp:hasActualEnd ?endInstLC . 
                    ?endInstLC occp:hasActualTime ?endLC . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstLC . 
                    ?endInstLC occp:hasEstimatedTime ?endLC . }
                    # Get embedding Phase
                    $this occp:isInPhase ?phase .
                    # Get Phase start time (actual or estimated)
                    { ?phase occp:hasActualBeginning ?startInstPhase . 
                    ?startInstPhase occp:hasActualTime ?startPhase . }
                    UNION
                    { ?phase occp:hasEstimatedBeginning ?startInstPhase . 
                    ?startInstPhase occp:hasEstimatedTime ?startPhase . }
                    # Get Phase end time (actual or estimated)
                    { ?phase occp:hasActualEnd ?endInstPhase . 
                    ?endInstPhase occp:hasActualTime ?endPhase . }
                    UNION
                    { ?phase occp:hasEstimatedEnd ?endInstPhase . 
                    ?endInstPhase occp:hasEstimatedTime ?endPhase . }
                    # Check conditions: startLC >= startPhase and endLC <= endPhase
                    FILTER (?startLC < ?startPhase || ?endLC > ?endPhase)
                }
            """ ;
            sh:message "Each 'occp:LifeCycle' { $this } (start: { ?startLC }, end: { ?endLC }) must have its beginning after or equal to the beginning of its embedding phase { ?phase } (start: { ?startPhase }) and its end before or equal to the end of the phase (end: { ?endPhase })."@en ;
            sh:severity sh:Violation
        ] .

### PHASE RELATED SHACL RULES

    osh:ShapeOfPhaseA a sh:NodeShape ;
        sh:targetClass occp:PhaseA_Planning ;
        # Ensure PhaseA begins before PhaseB_Review based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseB ?startA ?startB
                WHERE {
                    # Get start time of PhaseA (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantA . 
                    ?startInstantA occp:hasActualTime ?startA . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantA . 
                    ?startInstantA occp:hasEstimatedTime ?startA . }
                    # Get start time of PhaseB (actual or estimated)
                    ?phaseB a occp:PhaseB_Review .
                    { ?phaseB occp:hasActualBeginning ?startInstantB . 
                    ?startInstantB occp:hasActualTime ?startB . }
                    UNION
                    { ?phaseB occp:hasEstimatedBeginning ?startInstantB . 
                    ?startInstantB occp:hasEstimatedTime ?startB . }
                    FILTER (?startA >= ?startB)
                }
            """ ;
            sh:message "PhaseA_Planning { $this } (start: { ?startA }) must begin before PhaseB_Review { ?phaseB } (start: { ?startB })."@en ;
            sh:severity sh:Violation
        ] ;
        # Ensure PhaseA begins before PhaseC_Construction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?startA ?startC
                WHERE {
                    # Get start time of PhaseA (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantA . 
                    ?startInstantA occp:hasActualTime ?startA . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantA . 
                    ?startInstantA occp:hasEstimatedTime ?startA . }
                    # Get start time of PhaseC (actual or estimated)
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?startA >= ?startC)
                }
            """ ;
            sh:message "PhaseA_Planning { $this } (start: { ?startA }) must begin before PhaseC_Construction { ?phaseC } (start: { ?startC })."@en ;
            sh:severity sh:Violation
        ] ;
        # Ensure PhaseA ends before PhaseC_Construction begins based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?endA ?startC
                WHERE {
                    # Get end time of PhaseA (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantA . 
                    ?endInstantA occp:hasActualTime ?endA . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantA . 
                    ?endInstantA occp:hasEstimatedTime ?endA . }
                    # Get start time of PhaseC (actual or estimated)
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?endA >= ?startC)
                }
            """ ;
            sh:message "PhaseA_Planning { $this } (end: { ?endA }) must end before PhaseC_Construction { ?phaseC } begins (start: { ?startC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseA ends before CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?endA ?timeC
                WHERE {
                    # Get end time of PhaseA (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantA . 
                    ?endInstantA occp:hasActualTime ?endA . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantA . 
                    ?endInstantA occp:hasEstimatedTime ?endA . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completion a occp:CompletionOfConstruction .
                    { ?completion occp:hasActualTime ?timeC . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeC . }
                    FILTER (?endA >= ?timeC)
                }
            """ ;
            sh:message "PhaseA_Planning { $this } (end: { ?endA }) must end before CompletionOfConstruction { ?completion } (time: { ?timeC })."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:BeginningOfPlanning ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseA_Planning' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:BeginningOfPlanning'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:or (
                [ sh:class occp:ReviewApproval ]
                [ sh:class occp:CompletionOfPlanning ]
            ) ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseA_Planning' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:ReviewApproval' or 'occp:CompletionOfPlanning'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseB a sh:NodeShape ;
        sh:targetClass occp:PhaseB_Review ;
        # Ensure PhaseB begins before PhaseC_Construction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?startB ?startC
                WHERE {
                    { $this occp:hasActualBeginning ?startInstantB . 
                    ?startInstantB occp:hasActualTime ?startB . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantB . 
                    ?startInstantB occp:hasEstimatedTime ?startB . }
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?startB >= ?startC)
                }
            """ ;
            sh:message "PhaseB_Review { $this } (start: { ?startB }) must begin before PhaseC_Construction { ?phaseC } (start: { ?startC })."@en ;
            sh:severity sh:Violation
        ] ;
        # Ensure PhaseB occurs entirely before PhaseC_Construction (endB < startC) based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?endB ?startC
                WHERE {
                    { $this occp:hasActualEnd ?endInstantB . 
                    ?endInstantB occp:hasActualTime ?endB . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantB . 
                    ?endInstantB occp:hasEstimatedTime ?endB . }
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?endB >= ?startC)
                }
            """ ;
            sh:message "PhaseB_Review { $this } (end: { ?endB }) must end before PhaseC_Construction { ?phaseC } begins (start: { ?startC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseB ends before or with CompletionOfPlanning based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?endB ?timeCOP
                WHERE {
                    { $this occp:hasActualEnd ?endInstantB . 
                    ?endInstantB occp:hasActualTime ?endB . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantB . 
                    ?endInstantB occp:hasEstimatedTime ?endB . }
                    ?completion a occp:CompletionOfPlanning .
                    { ?completion occp:hasActualTime ?timeCOP . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeCOP . }
                    FILTER (?endB > ?timeCOP)
                }
            """ ;
            sh:message "PhaseB_Review { $this } (end: { ?endB }) must end before or with CompletionOfPlanning { ?completion } (time: { ?timeCOP })."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:SubmissionToReview ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseB_Review' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:SubmissionToReview'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:or (
                [ sh:class occp:ReviewApproval ]
                [ sh:class occp:CompletionOfPlanning ]
            ) ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseB_Review' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:ReviewApproval' or 'occp:CompletionOfPlanning'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfTransitionA a sh:NodeShape ;         # Transition A (Completion of Planning)
        sh:targetClass occp:CompletionOfPlanning ;
        # Ensure CompletionOfPlanning occurs before BeginOfTenderingProcess based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?beginTender ?timeCOP ?startTender
                WHERE {
                    # Get time of CompletionOfPlanning (actual or estimated)
                    { $this occp:hasActualTime ?timeCOP . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOP . }
                    # Get start time of BeginOfTenderingProcess (actual or estimated)
                    ?beginTender a occp:BeginOfTenderingProcess .
                    { ?beginTender occp:hasActualTime ?startTender . }
                    UNION
                    { ?beginTender occp:hasEstimatedTime ?startTender . }
                    FILTER (?timeCOP >= ?startTender)
                }
            """ ;
            sh:message "CompletionOfPlanning { $this } (time: { ?timeCOP }) should occur before BeginOfTenderingProcess { ?beginTender } (time: { ?startTender })."@en ;
            sh:severity sh:Warning
        ] .

    osh:ShapeOfTransitionB a sh:NodeShape ;         # Transition B (Begin Of Tendering Process)
        sh:targetClass occp:BeginOfTenderingProcess ;
        # Ensure BeginOfTenderingProcess occurs before Submission based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?submission ?startTender ?timeSub
                WHERE {
                    # Get time of BeginOfTenderingProcess (actual or estimated)
                    { $this occp:hasActualTime ?startTender . }
                    UNION
                    { $this occp:hasEstimatedTime ?startTender . }
                    # Get time of Submission (actual or estimated)
                    ?submission a occp:Submission .
                    { ?submission occp:hasActualTime ?timeSub . }
                    UNION
                    { ?submission occp:hasEstimatedTime ?timeSub . }
                    FILTER (?startTender >= ?timeSub)
                }
            """ ;
            sh:message "BeginOfTenderingProcess { $this } (time: { ?startTender }) should occur before Submission { ?submission } (time: { ?timeSub })."@en ;
            sh:severity sh:Warning
        ] .
    osh:ShapeOfTransitionC a sh:NodeShape ;         # Transition C (Submission)
        sh:targetClass occp:Submission ;
        # Ensure Submission occurs before PhaseC_Construction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseC ?timeSub ?startC
                WHERE {
                    # Get time of Submission (actual or estimated)
                    { $this occp:hasActualTime ?timeSub . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeSub . }
                    # Get start time of PhaseC_Construction (actual or estimated)
                    ?phaseC a occp:PhaseC_Construction .
                    { ?phaseC occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { ?phaseC occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    FILTER (?timeSub >= ?startC)
                }
            """ ;
            sh:message "Submission { $this } (time: { ?timeSub }) should occur before PhaseC_Construction { ?phaseC } (start: { ?startC })."@en ;
            sh:severity sh:Warning
        ] .

    osh:ShapeOfPhaseC a sh:NodeShape ;              # Phase C (Construction)
        sh:targetClass occp:PhaseC_Construction ;
        # Ensure PhaseC occurs after CompletionOfPlanning (startC > timeCOP) based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?startC ?timeCOP
                WHERE {
                    # Get start time of PhaseC (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    # Get time of CompletionOfPlanning (actual or estimated)
                    ?completion a occp:CompletionOfPlanning .
                    { ?completion occp:hasActualTime ?timeCOP . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeCOP . }
                    FILTER (?startC <= ?timeCOP)
                }
            """ ;
            sh:message "PhaseC_Construction { $this } (start: { ?startC }) should occur after CompletionOfPlanning { ?completion } (time: { ?timeCOP })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseC occurs after Submission (startC > timeSub) based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?submission ?startC ?timeSub
                WHERE {
                    # Get start time of PhaseC (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantC . 
                    ?startInstantC occp:hasActualTime ?startC . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantC . 
                    ?startInstantC occp:hasEstimatedTime ?startC . }
                    # Get time of Submission (actual or estimated)
                    ?submission a occp:Submission .
                    { ?submission occp:hasActualTime ?timeSub . }
                    UNION
                    { ?submission occp:hasEstimatedTime ?timeSub . }
                    FILTER (?startC <= ?timeSub)
                }
            """ ;
            sh:message "PhaseC_Construction { $this } (start: { ?startC }) should occur after Submission { ?submission } (time: { ?timeSub })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:ConstructionStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseC_Construction' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:ConstructionStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:CompletionOfConstruction ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseC_Construction' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:CompletionOfConstruction'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfTransitionD a sh:NodeShape ;         # Transition D (Completion Of Construction)
        sh:targetClass occp:CompletionOfConstruction ;
        # Ensure CompletionOfConstruction occurs after CompletionOfPlanning based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completionPlanning ?timeCOC ?timeCOP
                WHERE {
                    # Get time of CompletionOfConstruction (actual or estimated)
                    { $this occp:hasActualTime ?timeCOC . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOC . }
                    # Get time of CompletionOfPlanning (actual or estimated)
                    ?completionPlanning a occp:CompletionOfPlanning .
                    { ?completionPlanning occp:hasActualTime ?timeCOP . }
                    UNION
                    { ?completionPlanning occp:hasEstimatedTime ?timeCOP . }
                    FILTER (?timeCOC <= ?timeCOP)
                }
            """ ;
            sh:message "CompletionOfConstruction { $this } (time: { ?timeCOC }) should occur after CompletionOfPlanning { ?completionPlanning } (time: { ?timeCOP })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure CompletionOfConstruction occurs before PhaseD_Usage based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseD ?timeCOC ?startD
                WHERE {
                    # Get time of CompletionOfConstruction (actual or estimated)
                    { $this occp:hasActualTime ?timeCOC . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOC . }
                    # Get start time of PhaseD_Usage (actual or estimated)
                    ?phaseD a occp:PhaseD_Usage .
                    { ?phaseD occp:hasActualBeginning ?startInstantD . 
                    ?startInstantD occp:hasActualTime ?startD . }
                    UNION
                    { ?phaseD occp:hasEstimatedBeginning ?startInstantD . 
                    ?startInstantD occp:hasEstimatedTime ?startD . }
                    FILTER (?timeCOC >= ?startD)
                }
            """ ;
            sh:message "CompletionOfConstruction { $this } (time: { ?timeCOC }) should occur before PhaseD_Usage { ?phaseD } (start: { ?startD })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure CompletionOfConstruction occurs before PhaseM_Deconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?timeCOC ?startM
                WHERE {
                    # Get time of CompletionOfConstruction (actual or estimated)
                    { $this occp:hasActualTime ?timeCOC . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOC . }
                    # Get start time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    FILTER (?timeCOC >= ?startM)
                }
            """ ;
            sh:message "CompletionOfConstruction { $this } (time: { ?timeCOC }) should occur before PhaseM_Deconstruction { ?phaseM } (start: { ?startM })."@en ;
            sh:severity sh:Warning
        ] .

    osh:ShapeOfPhaseD a sh:NodeShape ;              # Phase D (Usage)
        sh:targetClass occp:PhaseD_Usage ;
        # Ensure PhaseD occurs after CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completionC ?startD ?timeCOC
                WHERE {
                    # Get start time of PhaseD (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantD . 
                    ?startInstantD occp:hasActualTime ?startD . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantD . 
                    ?startInstantD occp:hasEstimatedTime ?startD . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completionC a occp:CompletionOfConstruction .
                    { ?completionC occp:hasActualTime ?timeCOC . }
                    UNION
                    { ?completionC occp:hasEstimatedTime ?timeCOC . }
                    FILTER (?startD <= ?timeCOC)
                }
            """ ;
            sh:message "PhaseD_Usage { $this } (start: { ?startD }) should occur after CompletionOfConstruction { ?completionC } (time: { ?timeCOC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseD ends before PhaseM_Deconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?endD ?startM
                WHERE {
                    # Get end time of PhaseD (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantD . 
                    ?endInstantD occp:hasActualTime ?endD . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantD . 
                    ?endInstantD occp:hasEstimatedTime ?endD . }
                    # Get start time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    FILTER (?endD >= ?startM)
                }
            """ ;
            sh:message "PhaseD_Usage { $this } (end: { ?endD }) should end before PhaseM_Deconstruction { ?phaseM } (start: { ?startM }). We don’t want anyone to get hurt, do we?"@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:UsageStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseD_Usage' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:UsageStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:UsageEnd ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseD_Usage' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:UsageEnd'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseE a sh:NodeShape ;              # Phase E (Warranty)
        sh:targetClass occp:PhaseE_Warranty ;
        # Ensure PhaseE occurs after CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?startE ?timeCOC
                WHERE {
                    # Get start time of PhaseE (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantE . 
                    ?startInstantE occp:hasActualTime ?startE . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantE . 
                    ?startInstantE occp:hasEstimatedTime ?startE . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completion a occp:CompletionOfConstruction .
                    { ?completion occp:hasActualTime ?timeCOC . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeCOC . }
                    FILTER (?startE <= ?timeCOC)
                }
            """ ;
            sh:message "PhaseE_Warranty { $this } (start: { ?startE }) should occur after CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:WarrantyStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseE_Warranty' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:WarrantyStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:WarrantyEnd ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseE_Warranty' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:WarrantyEnd'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseF a sh:NodeShape ;              # Phase F (DesignLife)
        sh:targetClass occp:PhaseF_DesignLife ;
        # Ensure PhaseF occurs after CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completion ?startF ?timeCOC
                WHERE {
                    # Get start time of PhaseF (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantF . 
                    ?startInstantF occp:hasActualTime ?startF . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantF . 
                    ?startInstantF occp:hasEstimatedTime ?startF . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completion a occp:CompletionOfConstruction .
                    { ?completion occp:hasActualTime ?timeCOC . }
                    UNION
                    { ?completion occp:hasEstimatedTime ?timeCOC . }
                    FILTER (?startF <= ?timeCOC)
                }
            """ ;
            sh:message "PhaseF_DesignLife { $this } (start: { ?startF }) should occur after CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseF begins before or with PhaseD_Usage based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseD ?startF ?startD
                WHERE {
                    # Get start time of PhaseF (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantF . 
                    ?startInstantF occp:hasActualTime ?startF . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantF . 
                    ?startInstantF occp:hasEstimatedTime ?startF . }
                    # Get start time of PhaseD_Usage (actual or estimated)
                    ?phaseD a occp:PhaseD_Usage .
                    { ?phaseD occp:hasActualBeginning ?startInstantD . 
                    ?startInstantD occp:hasActualTime ?startD . }
                    UNION
                    { ?phaseD occp:hasEstimatedBeginning ?startInstantD . 
                    ?startInstantD occp:hasEstimatedTime ?startD . }
                    FILTER (?startF > ?startD)
                }
            """ ;
            sh:message "PhaseF_DesignLife { $this } (start: { ?startF }) should begin before or with PhaseD_Usage { ?phaseD } (start: { ?startD })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseF occurs before PhaseM_Deconstruction (endF < startM) based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?endF ?startM
                WHERE {
                    # Get end time of PhaseF (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantF . 
                    ?endInstantF occp:hasActualTime ?endF . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantF . 
                    ?endInstantF occp:hasEstimatedTime ?endF . }
                    # Get start time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    FILTER (?endF >= ?startM)
                }
            """ ;
            sh:message "PhaseF_DesignLife { $this } (end: { ?endF }) should occur before PhaseM_Deconstruction { ?phaseM } (start: { ?startM })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:DesignLifeStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseF_DesignLife' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:DesignLifeStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:DesignLifeEnd ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseF_DesignLife' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:DesignLifeEnd'."@en ;
            sh:severity sh:Violation
        ] .

osh:ShapeOfPhaseG a sh:NodeShape ;              # Phase G (Inspection)
    sh:targetClass occp:PhaseG_Inspection ;
    # Ensure PhaseG begins with or after UsageStart based on actual or estimated times
    sh:sparql [
        sh:select """
            PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
            PREFIX time: <http://www.w3.org/2006/time#>
            SELECT $this ?usageStart ?startG ?timeUS
            WHERE {
                # Get start time of PhaseG (actual or estimated)
                { $this occp:hasActualBeginning ?startInstantG . 
                  ?startInstantG occp:hasActualTime ?startG . }
                UNION
                { $this occp:hasEstimatedBeginning ?startInstantG . 
                  ?startInstantG occp:hasEstimatedTime ?startG . }
                # Get time of UsageStart (actual or estimated)
                ?usageStart a occp:UsageStart .
                { ?usageStart occp:hasActualTime ?timeUS . }
                UNION
                { ?usageStart occp:hasEstimatedTime ?timeUS . }
                FILTER (?startG < ?timeUS)
            }
        """ ;
        sh:message "PhaseG_Inspection { $this } (start: { ?startG }) must begin with or after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
        sh:severity sh:Violation
    ] ;
    # Ensure PhaseG occurs after CompletionOfConstruction based on actual or estimated times
    sh:sparql [
        sh:select """
            PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
            PREFIX time: <http://www.w3.org/2006/time#>
            SELECT $this ?completion ?startG ?timeCOC
            WHERE {
                # Get start time of PhaseG (actual or estimated)
                { $this occp:hasActualBeginning ?startInstantG . 
                  ?startInstantG occp:hasActualTime ?startG . }
                UNION
                { $this occp:hasEstimatedBeginning ?startInstantG . 
                  ?startInstantG occp:hasEstimatedTime ?startG . }
                # Get time of CompletionOfConstruction (actual or estimated)
                ?completion a occp:CompletionOfConstruction .
                { ?completion occp:hasActualTime ?timeCOC . }
                UNION
                { ?completion occp:hasEstimatedTime ?timeCOC . }
                FILTER (?startG <= ?timeCOC)
            }
        """ ;
        sh:message "PhaseG_Inspection { $this } (start: { ?startG }) should occur after CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
        sh:severity sh:Warning
    ] ;
    # Ensure PhaseG occurs before PhaseM_Deconstruction based on actual or estimated times
    sh:sparql [
        sh:select """
            PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
            PREFIX time: <http://www.w3.org/2006/time#>
            SELECT $this ?phaseM ?endG ?startM
            WHERE {
                # Get end time of PhaseG (actual or estimated)
                { $this occp:hasActualEnd ?endInstantG . 
                  ?endInstantG occp:hasActualTime ?endG . }
                UNION
                { $this occp:hasEstimatedEnd ?endInstantG . 
                  ?endInstantG occp:hasEstimatedTime ?endG . }
                # Get start time of PhaseM_Deconstruction (actual or estimated)
                ?phaseM a occp:PhaseM_Deconstruction .
                { ?phaseM occp:hasActualBeginning ?startInstantM . 
                  ?startInstantM occp:hasActualTime ?startM . }
                UNION
                { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                  ?startInstantM occp:hasEstimatedTime ?startM . }
                FILTER (?endG >= ?startM)
            }
        """ ;
        sh:message "PhaseG_Inspection { $this } (end: { ?endG }) should occur before PhaseM_Deconstruction { ?phaseM } (start: { ?startM })."@en ;
        sh:severity sh:Warning
    ] ;
    # Constraint for hasActualBeginning
    sh:property [
        sh:path occp:hasActualBeginning ;
        sh:class occp:InspectionExecution ;
        sh:maxCount 1 ;
        sh:message "Each 'occp:PhaseG_Inspection' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:InspectionExecution'."@en ;
        sh:severity sh:Violation
    ] ;
    # Constraint for hasActualEnd
    sh:property [
        sh:path occp:hasActualEnd ;
        sh:class time:Instant ;
        sh:maxCount 1 ;
        sh:message "Each 'occp:PhaseG_Inspection' must have at most one actual end via 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
        sh:severity sh:Violation
    ] .


    osh:ShapeOfPhaseH a sh:NodeShape ;              # Phase H (SpecialEvents) - Special events can occur anytime, so this is to be handled like a super-phase. It can be used to describe or record events that have shaped the landscape like earthquakes in the past, but also events that occur during or after the construction's life cycle.
        sh:targetClass occp:PhaseH_SpecialEvents ;
        # Ensure each PhaseH has at least one instant to mark specific events
        sh:property [
            sh:path occp:hasInstant ;
            sh:class time:Instant ;
            sh:minCount 1 ;
            sh:message "Each 'occp:PhaseH_SpecialEvents' must have at least one instant via 'occp:hasInstant' referencing a 'time:Instant' (e.g., 'occp:GeologicalEvent', 'occp:WeatherEvent')."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseH_SpecialEvents' must have at most one actual beginning via 'occp:hasActualBeginning' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseH_SpecialEvents' must have at most one actual end via 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseK a sh:NodeShape ;              # Phase K (Damage)
        sh:targetClass occp:PhaseK_Damage ;
        # Ensure PhaseK occurs after Submission based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?submission ?startK ?timeSub
                WHERE {
                    # Get start time of PhaseK (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantK . 
                    ?startInstantK occp:hasActualTime ?startK . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantK . 
                    ?startInstantK occp:hasEstimatedTime ?startK . }
                    # Get time of Submission (actual or estimated)
                    ?submission a occp:Submission .
                    { ?submission occp:hasActualTime ?timeSub . }
                    UNION
                    { ?submission occp:hasEstimatedTime ?timeSub . }
                    FILTER (?startK <= ?timeSub)
                }
            """ ;
            sh:message "PhaseK_Damage { $this } (start: { ?startK }) should occur after Submission { ?submission } (time: { ?timeSub })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseK occurs before CompletionOfDeconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completionDec ?endK ?timeCOD
                WHERE {
                    # Get end time of PhaseK (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantK . 
                    ?endInstantK occp:hasActualTime ?endK . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantK . 
                    ?endInstantK occp:hasEstimatedTime ?endK . }
                    # Get time of CompletionOfDeconstruction (actual or estimated)
                    ?completionDec a occp:CompletionOfDeconstruction .
                    { ?completionDec occp:hasActualTime ?timeCOD . }
                    UNION
                    { ?completionDec occp:hasEstimatedTime ?timeCOD . }
                    FILTER (?endK >= ?timeCOD)
                }
            """ ;
            sh:message "PhaseK_Damage { $this } (end: { ?endK }) should occur before CompletionOfDeconstruction { ?completionDec } (time: { ?timeCOD })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseK begins before PhaseL_Repair based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseL ?startK ?startL
                WHERE {
                    # Get start time of PhaseK (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantK . 
                    ?startInstantK occp:hasActualTime ?startK . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantK . 
                    ?startInstantK occp:hasEstimatedTime ?startK . }
                    # Get start time of PhaseL_Repair (actual or estimated)
                    ?phaseL a occp:PhaseL_Repair .
                    { ?phaseL occp:hasActualBeginning ?startInstantL . 
                    ?startInstantL occp:hasActualTime ?startL . }
                    UNION
                    { ?phaseL occp:hasEstimatedBeginning ?startInstantL . 
                    ?startInstantL occp:hasEstimatedTime ?startL . }
                    FILTER (?startK >= ?startL)
                }
            """ ;
            sh:message "PhaseK_Damage { $this } (start: { ?startK }) should begin before PhaseL_Repair { ?phaseL } (start: { ?startL }), but damage detection during repair is possible."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:DamageDetection ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseK_Damage' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:DamageDetection'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class time:Instant ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseK_Damage' must have at most one actual end via 'occp:hasActualEnd' referencing a 'time:Instant'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseL a sh:NodeShape ;              # Phase L (Repair)
        sh:targetClass occp:PhaseL_Repair ;
        # Ensure PhaseL ends with or after PhaseK_Damage based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseK ?endL ?endK
                WHERE {
                    # Get end time of PhaseL (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantL . 
                    ?endInstantL occp:hasActualTime ?endL . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantL . 
                    ?endInstantL occp:hasEstimatedTime ?endL . }
                    # Get end time of PhaseK_Damage (actual or estimated)
                    ?phaseK a occp:PhaseK_Damage .
                    { ?phaseK occp:hasActualEnd ?endInstantK . 
                    ?endInstantK occp:hasActualTime ?endK . }
                    UNION
                    { ?phaseK occp:hasEstimatedEnd ?endInstantK . 
                    ?endInstantK occp:hasEstimatedTime ?endK . }
                    FILTER (?endL < ?endK)
                }
            """ ;
            sh:message "PhaseL_Repair { $this } (end: { ?endL }) must end with or after PhaseK_Damage { ?phaseK } (end: { ?endK })."@en ;
            sh:severity sh:Violation
        ] ;
        # Ensure PhaseL occurs after Submission based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?submission ?startL ?timeSub
                WHERE {
                    # Get start time of PhaseL (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantL . 
                    ?startInstantL occp:hasActualTime ?startL . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantL . 
                    ?startInstantL occp:hasEstimatedTime ?startL . }
                    # Get time of Submission (actual or estimated)
                    ?submission a occp:Submission .
                    { ?submission occp:hasActualTime ?timeSub . }
                    UNION
                    { ?submission occp:hasEstimatedTime ?timeSub . }
                    FILTER (?startL <= ?timeSub)
                }
            """ ;
            sh:message "PhaseL_Repair { $this } (start: { ?startL }) should occur after Submission { ?submission } (time: { ?timeSub })."@en ;
            sh:severity sh:Warning
        ] ;
        # Ensure PhaseL ends before PhaseM_Deconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?endL ?startM
                WHERE {
                    # Get end time of PhaseL (actual or estimated)
                    { $this occp:hasActualEnd ?endInstantL . 
                    ?endInstantL occp:hasActualTime ?endL . }
                    UNION
                    { $this occp:hasEstimatedEnd ?endInstantL . 
                    ?endInstantL occp:hasEstimatedTime ?endL . }
                    # Get start time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { ?phaseM occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    FILTER (?endL >= ?startM)
                }
            """ ;
            sh:message "PhaseL_Repair { $this } (end: { ?endL }) should end before PhaseM_Deconstruction { ?phaseM } (start: { ?startM })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:RepairStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseL_Repair' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:RepairStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:RepairCompletion ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseL_Repair' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:RepairCompletion'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfPhaseM a sh:NodeShape ;              # Phase M (Deconstruction)
        sh:targetClass occp:PhaseM_Deconstruction ;
        # Ensure PhaseM occurs after CompletionOfConstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?completionC ?startM ?timeCOC
                WHERE {
                    # Get start time of PhaseM (actual or estimated)
                    { $this occp:hasActualBeginning ?startInstantM . 
                    ?startInstantM occp:hasActualTime ?startM . }
                    UNION
                    { $this occp:hasEstimatedBeginning ?startInstantM . 
                    ?startInstantM occp:hasEstimatedTime ?startM . }
                    # Get time of CompletionOfConstruction (actual or estimated)
                    ?completionC a occp:CompletionOfConstruction .
                    { ?completionC occp:hasActualTime ?timeCOC . }
                    UNION
                    { ?completionC occp:hasEstimatedTime ?timeCOC . }
                    FILTER (?startM <= ?timeCOC)
                }
            """ ;
            sh:message "PhaseM_Deconstruction { $this } (start: { ?startM }) should occur after CompletionOfConstruction { ?completionC } (time: { ?timeCOC })."@en ;
            sh:severity sh:Warning
        ] ;
        # Constraint for hasActualBeginning
        sh:property [
            sh:path occp:hasActualBeginning ;
            sh:class occp:DeconstructionStart ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseM_Deconstruction' must have at most one actual beginning via 'occp:hasActualBeginning' referencing 'occp:DeconstructionStart'."@en ;
            sh:severity sh:Violation
        ] ;
        # Constraint for hasActualEnd
        sh:property [
            sh:path occp:hasActualEnd ;
            sh:class occp:CompletionOfDeconstruction ;
            sh:maxCount 1 ;
            sh:message "Each 'occp:PhaseM_Deconstruction' must have at most one actual end via 'occp:hasActualEnd' referencing 'occp:CompletionOfDeconstruction'."@en ;
            sh:severity sh:Violation
        ] .

    osh:ShapeOfTransitionE a sh:NodeShape ;         # Transition E (Completion Of Deconstruction)
        sh:targetClass occp:CompletionOfDeconstruction ;
        # Ensure CompletionOfDeconstruction occurs after or with the end of PhaseM_Deconstruction based on actual or estimated times
        sh:sparql [
            sh:select """
                PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                PREFIX time: <http://www.w3.org/2006/time#>
                SELECT $this ?phaseM ?timeCOD ?endM
                WHERE {
                    # Get time of CompletionOfDeconstruction (actual or estimated)
                    { $this occp:hasActualTime ?timeCOD . }
                    UNION
                    { $this occp:hasEstimatedTime ?timeCOD . }
                    # Get end time of PhaseM_Deconstruction (actual or estimated)
                    ?phaseM a occp:PhaseM_Deconstruction .
                    { ?phaseM occp:hasActualEnd ?endInstantM . 
                    ?endInstantM occp:hasActualTime ?endM . }
                    UNION
                    { ?phaseM occp:hasEstimatedEnd ?endInstantM . 
                    ?endInstantM occp:hasEstimatedTime ?endM . }
                    FILTER (?timeCOD < ?endM)
                }
            """ ;
            sh:message "CompletionOfDeconstruction { $this } (time: { ?timeCOD }) must occur after or with the end of PhaseM_Deconstruction { ?phaseM } (end: { ?endM })."@en ;
            sh:severity sh:Violation
        ] .






