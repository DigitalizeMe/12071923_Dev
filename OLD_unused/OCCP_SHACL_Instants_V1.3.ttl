@prefix sh:    <http://www.w3.org/ns/shacl#> .
@prefix xsd:   <http://www.w3.org/2001/XMLSchema#> .
@prefix occp:  <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#> .
@prefix time:  <http://www.w3.org/2006/time#> .
@prefix osh:   <http://www.occpshape.de/shape#> .


### INSTANT RELATED SHACL RULES
    ### PHASE A INSTANTS
        # PHASE ASSIGNMENT

            osh:PhaseAInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseA_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseA_Planning ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseA_Instant' must belong to exactly one 'occp:PhaseA_Planning' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE A - PLANNING

            osh:BeginningOfPlanningShape a sh:NodeShape ;   # Instant Beginning Of Planning (Phase A - Planning)
                sh:targetClass occp:BeginningOfPlanning ;
                # Instant (Beginning Of Planning) starts a new Phase A (Planning)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseA_Planning ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:BeginningOfPlanning' must start exactly one 'occp:PhaseA_Planning' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure BeginningOfPlanning occurs before DataProcurement based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?dataProc ?timeBOP ?timeDP
                        WHERE {
                            # Get time of BeginningOfPlanning (actual or estimated)
                            { $this occp:hasActualTime ?timeBOP . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeBOP . }
                            # Get time of DataProcurement (actual or estimated)
                            ?dataProc a occp:DataProcurement .
                            { ?dataProc occp:hasActualTime ?timeDP . }
                            UNION
                            { ?dataProc occp:hasEstimatedTime ?timeDP . }
                            FILTER (?timeBOP >= ?timeDP)
                        }
                    """ ;
                    sh:message "BeginningOfPlanning { $this } (time: { ?timeBOP }) must occur before DataProcurement { ?dataProc } (time: { ?timeDP })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure BeginningOfPlanning occurs before SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeBOP ?timeSub
                        WHERE {
                            # Get time of BeginningOfPlanning (actual or estimated)
                            { $this occp:hasActualTime ?timeBOP . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeBOP . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeBOP >= ?timeSub)
                        }
                    """ ;
                    sh:message "BeginningOfPlanning { $this } (time: { ?timeBOP }) should occur before SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Warning
                ] .

            osh:DataProcurementShape a sh:NodeShape ;       # Instant Data Procurement (Phase A - Planning)
                sh:targetClass occp:DataProcurement ;
                # Ensure DataProcurement occurs after BeginningOfPlanning based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?beginPlanning ?timeDP ?timeBOP
                        WHERE {
                            # Get time of DataProcurement (actual or estimated)
                            { $this occp:hasActualTime ?timeDP . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDP . }
                            # Get time of BeginningOfPlanning (actual or estimated)
                            ?beginPlanning a occp:BeginningOfPlanning .
                            { ?beginPlanning occp:hasActualTime ?timeBOP . }
                            UNION
                            { ?beginPlanning occp:hasEstimatedTime ?timeBOP . }
                            FILTER (?timeDP <= ?timeBOP)
                        }
                    """ ;
                    sh:message "DataProcurement { $this } (time: { ?timeDP }) must occur after BeginningOfPlanning { ?beginPlanning } (time: { ?timeBOP })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DataProcurement occurs before SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeDP ?timeSub
                        WHERE {
                            # Get time of DataProcurement (actual or estimated)
                            { $this occp:hasActualTime ?timeDP . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDP . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeDP >= ?timeSub)
                        }
                    """ ;
                    sh:message "DataProcurement { $this } (time: { ?timeDP }) should occur before SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Warning
                ] .

            osh:Edit_BSTRShape a sh:NodeShape ;             # Instant Edit Before Submission To Review (Phase A - Planning)
                sh:targetClass occp:Edit_BSTR ;
                # Ensure Edit_BSTR occurs after BeginningOfPlanning based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?beginPlanning ?timeEdit ?timeBOP
                        WHERE {
                            # Get time of Edit_BSTR (actual or estimated)
                            { $this occp:hasActualTime ?timeEdit . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeEdit . }
                            # Get time of BeginningOfPlanning (actual or estimated)
                            ?beginPlanning a occp:BeginningOfPlanning .
                            { ?beginPlanning occp:hasActualTime ?timeBOP . }
                            UNION
                            { ?beginPlanning occp:hasEstimatedTime ?timeBOP . }
                            FILTER (?timeEdit <= ?timeBOP)
                        }
                    """ ;
                    sh:message "Edit_BSTR { $this } (time: { ?timeEdit }) must occur after BeginningOfPlanning { ?beginPlanning } (time: { ?timeBOP })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure Edit_BSTR occurs before SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeEdit ?timeSub
                        WHERE {
                            # Get time of Edit_BSTR (actual or estimated)
                            { $this occp:hasActualTime ?timeEdit . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeEdit . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeEdit >= ?timeSub)
                        }
                    """ ;
                    sh:message "Edit_BSTR { $this } (time: { ?timeEdit }) must occur before SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:SubmissionToReviewShape a sh:NodeShape ;    # Instant Submission To Review (Phase A - Planning)
                sh:targetClass occp:SubmissionToReview ;
                # Ensure SubmissionToReview occurs after Edit_BSTR or Edit_ASTR based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?editEvent ?timeSub ?timeEdit
                        WHERE {
                            # Get time of SubmissionToReview (actual or estimated)
                            { $this occp:hasActualTime ?timeSub . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeSub . }
                            # Get time of Edit_BSTR or Edit_ASTR (actual or estimated)
                            ?editEvent a ?editClass .
                            FILTER (?editClass IN (occp:Edit_BSTR, occp:Edit_ASTR))
                            { ?editEvent occp:hasActualTime ?timeEdit . }
                            UNION
                            { ?editEvent occp:hasEstimatedTime ?timeEdit . }
                            FILTER (?timeSub <= ?timeEdit)
                        }
                    """ ;
                    sh:message "SubmissionToReview { $this } (time: { ?timeSub }) must occur after Edit_BSTR or Edit_ASTR { ?editEvent } (time: { ?timeEdit })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Instant starts a CycleA_PlanningReview
                sh:property [
                    sh:path occp:startsCycle ;
                    sh:class occp:CycleA_PlanningReview ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:SubmissionToReview' must start at most one 'occp:CycleA_PlanningReview' via 'occp:startsCycle'."@en ;
                    sh:severity sh:Violation
                ] .

            osh:Edit_ASTRShape a sh:NodeShape ;             # Instant Edit After Submission To Review (Phase A - Planning)
                sh:targetClass occp:Edit_ASTR ;
                # Ensure Edit_ASTR occurs after SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeEdit ?timeSub
                        WHERE {
                            # Get time of Edit_ASTR (actual or estimated)
                            { $this occp:hasActualTime ?timeEdit . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeEdit . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeEdit <= ?timeSub)
                        }
                    """ ;
                    sh:message "Edit_ASTR { $this } (time: { ?timeEdit }) must occur after SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure Edit_ASTR occurs before CompletionOfPlanning based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeEdit ?timeCOP
                        WHERE {
                            # Get time of Edit_ASTR (actual or estimated)
                            { $this occp:hasActualTime ?timeEdit . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeEdit . }
                            # Get time of CompletionOfPlanning (actual or estimated)
                            ?completion a occp:CompletionOfPlanning .
                            { ?completion occp:hasActualTime ?timeCOP . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCOP . }
                            FILTER (?timeEdit >= ?timeCOP)
                        }
                    """ ;
                    sh:message "Edit_ASTR { $this } (time: { ?timeEdit }) should occur before CompletionOfPlanning { ?completion } (time: { ?timeCOP })."@en ;
                    sh:severity sh:Warning
                ] .


    ### PHASE B INSTANTS
        # PHASE ASSIGNMENT        
        
            osh:PhaseBInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseB_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseB_Review ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseB_Instant' must belong to exactly one 'occp:PhaseB_Review' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE B - REVIEW

            osh:ReviewStartShape a sh:NodeShape ;           # Instant Review Start (Phase B - Review)
                sh:targetClass occp:ReviewStart ;
                # Instant (Review Start) starts a new Phase B (Review)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseB_Review ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewStart' must start exactly one 'occp:PhaseB_Review' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ReviewStart occurs before ReviewApproval based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?reviewApproval ?timeRS ?timeRA
                        WHERE {
                            # Get time of ReviewStart (actual or estimated)
                            { $this occp:hasActualTime ?timeRS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRS . }
                            # Get time of ReviewApproval (actual or estimated)
                            ?reviewApproval a occp:ReviewApproval .
                            { ?reviewApproval occp:hasActualTime ?timeRA . }
                            UNION
                            { ?reviewApproval occp:hasEstimatedTime ?timeRA . }
                            FILTER (?timeRS >= ?timeRA)
                        }
                    """ ;
                    sh:message "ReviewStart { $this } (time: { ?timeRS }) must occur before ReviewApproval { ?reviewApproval } (time: { ?timeRA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ReviewStart occurs before ReviewRejection based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?reviewRejection ?timeRS ?timeRR
                        WHERE {
                            # Get time of ReviewStart (actual or estimated)
                            { $this occp:hasActualTime ?timeRS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRS . }
                            # Get time of ReviewRejection (actual or estimated)
                            ?reviewRejection a occp:ReviewRejection .
                            { ?reviewRejection occp:hasActualTime ?timeRR . }
                            UNION
                            { ?reviewRejection occp:hasEstimatedTime ?timeRR . }
                            FILTER (?timeRS >= ?timeRR)
                        }
                    """ ;
                    sh:message "ReviewStart { $this } (time: { ?timeRS }) must occur before ReviewRejection { ?reviewRejection } (time: { ?timeRR })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ReviewStart occurs after SubmissionToReview based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeRS ?timeSub
                        WHERE {
                            # Get time of ReviewStart (actual or estimated)
                            { $this occp:hasActualTime ?timeRS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRS . }
                            # Get time of SubmissionToReview (actual or estimated)
                            ?submission a occp:SubmissionToReview .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeRS <= ?timeSub)
                        }
                    """ ;
                    sh:message "ReviewStart { $this } (time: { ?timeRS }) must occur after SubmissionToReview { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:ReviewApprovalShape a sh:NodeShape ;
                sh:targetClass occp:ReviewApproval ;
                # Optional: endsPhase for PhaseA_Planning if it exists, max 1
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?phaseA ?timeRA ?startA
                        WHERE {
                            ?phaseA a occp:PhaseA_Planning .
                            $this occp:endsPhase ?phaseA .
                            # Get time of ReviewApproval (actual or estimated)
                            { $this occp:hasActualTime ?timeRA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRA . }
                            # Get start time of PhaseA (actual or estimated)
                            { ?phaseA occp:hasActualBeginning ?startInstA . 
                            ?startInstA occp:hasActualTime ?startA . }
                            UNION
                            { ?phaseA occp:hasEstimatedBeginning ?startInstA . 
                            ?startInstA occp:hasEstimatedTime ?startA . }
                            FILTER (?timeRA <= ?startA)
                        }
                    """ ;
                    sh:message "ReviewApproval { $this } (time: { ?timeRA }) must occur after the start of PhaseA_Planning { ?phaseA } (start: { ?startA })."@en ;
                    sh:severity sh:Violation
                ] ;
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseA_Planning ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewApproval' must end at most one 'occp:PhaseA_Planning' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Optional: endsPhase for PhaseB_Review if it exists, max 1
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?phaseB ?timeRA ?startB
                        WHERE {
                            ?phaseB a occp:PhaseB_Review .
                            $this occp:endsPhase ?phaseB .
                            # Get time of ReviewApproval (actual or estimated)
                            { $this occp:hasActualTime ?timeRA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRA . }
                            # Get start time of PhaseB (actual or estimated)
                            { ?phaseB occp:hasActualBeginning ?startInstB . 
                            ?startInstB occp:hasActualTime ?startB . }
                            UNION
                            { ?phaseB occp:hasEstimatedBeginning ?startInstB . 
                            ?startInstB occp:hasEstimatedTime ?startB . }
                            FILTER (?timeRA <= ?startB)
                        }
                    """ ;
                    sh:message "ReviewApproval { $this } (time: { ?timeRA }) must occur after the start of PhaseB_Review { ?phaseB } (start: { ?startB })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Optional: endsCycle for CycleA_PlanningReview if it exists, max 1
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?cycleA ?timeRA ?startA
                        WHERE {
                            ?cycleA a occp:CycleA_PlanningReview .
                            $this occp:endsCycle ?cycleA .
                            # Get time of ReviewApproval (actual or estimated)
                            { $this occp:hasActualTime ?timeRA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRA . }
                            # Get start time of CycleA (actual or estimated)
                            { ?cycleA occp:hasActualBeginning ?startInstA . 
                            ?startInstA occp:hasActualTime ?startA . }
                            UNION
                            { ?cycleA occp:hasEstimatedBeginning ?startInstA . 
                            ?startInstA occp:hasEstimatedTime ?startA . }
                            FILTER (?timeRA <= ?startA)
                        }
                    """ ;
                    sh:message "ReviewApproval { $this } (time: { ?timeRA }) must occur after the start of CycleA_PlanningReview { ?cycleA } (start: { ?startA })."@en ;
                    sh:severity sh:Violation
                ] ;
                sh:property [
                    sh:path occp:endsCycle ;
                    sh:class occp:CycleA_PlanningReview ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewApproval' must end at most one 'occp:CycleA_PlanningReview' via 'occp:endsCycle'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ReviewApproval occurs after ReviewStart if it exists
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?reviewStart ?timeRA ?timeRS
                        WHERE {
                            # Get time of ReviewApproval (actual or estimated)
                            { $this occp:hasActualTime ?timeRA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRA . }
                            # Get time of ReviewStart (actual or estimated)
                            ?reviewStart a occp:ReviewStart .
                            { ?reviewStart occp:hasActualTime ?timeRS . }
                            UNION
                            { ?reviewStart occp:hasEstimatedTime ?timeRS . }
                            FILTER (?timeRA <= ?timeRS)
                        }
                    """ ;
                    sh:message "ReviewApproval { $this } (time: { ?timeRA }) must occur after ReviewStart { ?reviewStart } (time: { ?timeRS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:ReviewRejectionShape a sh:NodeShape ;       # Instant Review Rejection (Phase B - Review)
                sh:targetClass occp:ReviewRejection ;
                # Ensure ReviewRejection occurs after ReviewStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?reviewStart ?timeRR ?timeRS
                        WHERE {
                            # Get time of ReviewRejection (actual or estimated)
                            { $this occp:hasActualTime ?timeRR . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeRR . }
                            # Get time of ReviewStart (actual or estimated)
                            ?reviewStart a occp:ReviewStart .
                            { ?reviewStart occp:hasActualTime ?timeRS . }
                            UNION
                            { ?reviewStart occp:hasEstimatedTime ?timeRS . }
                            FILTER (?timeRR <= ?timeRS)
                        }
                    """ ;
                    sh:message "ReviewRejection { $this } (time: { ?timeRR }) must occur after ReviewStart { ?reviewStart } (time: { ?timeRS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Instant (Review Rejection) ends current Cycle A (Planning/Review)
                sh:property [
                    sh:path occp:endsCycle ;
                    sh:class occp:CycleA_PlanningReview ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewRejection' must end exactly one 'occp:CycleA_PlanningReview' via 'occp:endsCycle'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Instant (Review Rejection) starts a new Cycle A (Planning/Review)
                sh:property [
                    sh:path occp:startsCycle ;
                    sh:class occp:CycleA_PlanningReview ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ReviewRejection' must start exactly one new 'occp:CycleA_PlanningReview' via 'occp:startsCycle'."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE C INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseCInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseC_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseC_Construction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseC_Instant' must belong to exactly one 'occp:PhaseC_Construction' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE C - CONSTRUCTION

            osh:ConstructionStartShape a sh:NodeShape ;      # Instant Construction Start (Phase C - Construction)
                sh:targetClass occp:ConstructionStart ;
                # Instant (Construction Start) starts a new Phase C (Construction)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseC_Construction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:ConstructionStart' must start exactly one 'occp:PhaseC_Construction' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionStart occurs before ConstructionCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeCS ?timeCC
                        WHERE {
                            { $this occp:hasActualTime ?timeCS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCS . }
                            ?completion a occp:ConstructionCompletion .
                            { ?completion occp:hasActualTime ?timeCC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCC . }
                            FILTER (?timeCS >= ?timeCC)
                        }
                    """ ;
                    sh:message "ConstructionStart { $this } (time: { ?timeCS }) must occur before ConstructionCompletion { ?completion } (time: { ?timeCC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionStart occurs after Submission based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?submission ?timeCS ?timeSub
                        WHERE {
                            { $this occp:hasActualTime ?timeCS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCS . }
                            ?submission a occp:Submission .
                            { ?submission occp:hasActualTime ?timeSub . }
                            UNION
                            { ?submission occp:hasEstimatedTime ?timeSub . }
                            FILTER (?timeCS <= ?timeSub)
                        }
                    """ ;
                    sh:message "ConstructionStart { $this } (time: { ?timeCS }) must occur after Submission { ?submission } (time: { ?timeSub })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:ConstructionCompletionShape a sh:NodeShape ; # Instant Construction Completion (Phase C - Construction)
                sh:targetClass occp:ConstructionCompletion ;
                # Ensure ConstructionCompletion occurs after ConstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?start ?timeCC ?timeCS
                        WHERE {
                            { $this occp:hasActualTime ?timeCC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCC . }
                            ?start a occp:ConstructionStart .
                            { ?start occp:hasActualTime ?timeCS . }
                            UNION
                            { ?start occp:hasEstimatedTime ?timeCS . }
                            FILTER (?timeCC <= ?timeCS)
                        }
                    """ ;
                    sh:message "ConstructionCompletion { $this } (time: { ?timeCC }) must occur after ConstructionStart { ?start } (time: { ?timeCS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionCompletion occurs before ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?acceptance ?timeCC ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeCC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCC . }
                            ?acceptance a occp:ConstructionAcceptance .
                            { ?acceptance occp:hasActualTime ?timeCA . }
                            UNION
                            { ?acceptance occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeCC >= ?timeCA)
                        }
                    """ ;
                    sh:message "ConstructionCompletion { $this } (time: { ?timeCC }) must occur before ConstructionAcceptance { ?acceptance } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionCompletion occurs before DefectElimStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?defectStart ?timeCC ?timeDES
                        WHERE {
                            { $this occp:hasActualTime ?timeCC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCC . }
                            ?defectStart a occp:DefectElimStart .
                            { ?defectStart occp:hasActualTime ?timeDES . }
                            UNION
                            { ?defectStart occp:hasEstimatedTime ?timeDES . }
                            FILTER (?timeCC >= ?timeDES)
                        }
                    """ ;
                    sh:message "ConstructionCompletion { $this } (time: { ?timeCC }) must occur before DefectElimStart { ?defectStart } (time: { ?timeDES })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DefectElimStartShape a sh:NodeShape ;        # Instant Defect Elimination Start (Phase C - Construction)
                sh:targetClass occp:DefectElimStart ;
                # Ensure DefectElimStart occurs after ConstructionCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeDES ?timeCC
                        WHERE {
                            { $this occp:hasActualTime ?timeDES . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDES . }
                            ?completion a occp:ConstructionCompletion .
                            { ?completion occp:hasActualTime ?timeCC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCC . }
                            FILTER (?timeDES <= ?timeCC)
                        }
                    """ ;
                    sh:message "DefectElimStart { $this } (time: { ?timeDES }) must occur after ConstructionCompletion { ?completion } (time: { ?timeCC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DefectElimStart occurs before DefectElimCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?defectComp ?timeDES ?timeDEC
                        WHERE {
                            { $this occp:hasActualTime ?timeDES . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDES . }
                            ?defectComp a occp:DefectElimCompletion .
                            { ?defectComp occp:hasActualTime ?timeDEC . }
                            UNION
                            { ?defectComp occp:hasEstimatedTime ?timeDEC . }
                            FILTER (?timeDES >= ?timeDEC)
                        }
                    """ ;
                    sh:message "DefectElimStart { $this } (time: { ?timeDES }) must occur before DefectElimCompletion { ?defectComp } (time: { ?timeDEC })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DefectElimCompletionShape a sh:NodeShape ;   # Instant Defect Elimination Completion (Phase C - Construction)
                sh:targetClass occp:DefectElimCompletion ;
                # Ensure DefectElimCompletion occurs after DefectElimStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?defectStart ?timeDEC ?timeDES
                        WHERE {
                            { $this occp:hasActualTime ?timeDEC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDEC . }
                            ?defectStart a occp:DefectElimStart .
                            { ?defectStart occp:hasActualTime ?timeDES . }
                            UNION
                            { ?defectStart occp:hasEstimatedTime ?timeDES . }
                            FILTER (?timeDEC <= ?timeDES)
                        }
                    """ ;
                    sh:message "DefectElimCompletion { $this } (time: { ?timeDEC }) must occur after DefectElimStart { ?defectStart } (time: { ?timeDES })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DefectElimCompletion occurs before ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?acceptance ?timeDEC ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeDEC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDEC . }
                            ?acceptance a occp:ConstructionAcceptance .
                            { ?acceptance occp:hasActualTime ?timeCA . }
                            UNION
                            { ?acceptance occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDEC >= ?timeCA)
                        }
                    """ ;
                    sh:message "DefectElimCompletion { $this } (time: { ?timeDEC }) must occur before ConstructionAcceptance { ?acceptance } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:ConstructionAcceptanceShape a sh:NodeShape ; # Instant Construction Acceptance (Phase C - Construction)
                sh:targetClass occp:ConstructionAcceptance ;
                # Ensure ConstructionAcceptance occurs before UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeCA ?timeUS
                        WHERE {
                            { $this occp:hasActualTime ?timeCA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCA . }
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeCA >= ?timeUS)
                        }
                    """ ;
                    sh:message "ConstructionAcceptance { $this } (time: { ?timeCA }) should occur before UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Warning
                ] ;
                # Ensure ConstructionAcceptance occurs before CompletionOfConstruction based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeCA ?timeCOC
                        WHERE {
                            { $this occp:hasActualTime ?timeCA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCA . }
                            ?completion a occp:CompletionOfConstruction .
                            { ?completion occp:hasActualTime ?timeCOC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCOC . }
                            FILTER (?timeCA >= ?timeCOC)
                        }
                    """ ;
                    sh:message "ConstructionAcceptance { $this } (time: { ?timeCA }) must occur before CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionAcceptance occurs after ConstructionCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeCA ?timeCC
                        WHERE {
                            { $this occp:hasActualTime ?timeCA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCA . }
                            ?completion a occp:ConstructionCompletion .
                            { ?completion occp:hasActualTime ?timeCC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCC . }
                            FILTER (?timeCA <= ?timeCC)
                        }
                    """ ;
                    sh:message "ConstructionAcceptance { $this } (time: { ?timeCA }) must occur after ConstructionCompletion { ?completion } (time: { ?timeCC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure ConstructionAcceptance occurs after DefectElimCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?defectComp ?timeCA ?timeDEC
                        WHERE {
                            { $this occp:hasActualTime ?timeCA . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeCA . }
                            ?defectComp a occp:DefectElimCompletion .
                            { ?defectComp occp:hasActualTime ?timeDEC . }
                            UNION
                            { ?defectComp occp:hasEstimatedTime ?timeDEC . }
                            FILTER (?timeCA <= ?timeDEC)
                        }
                    """ ;
                    sh:message "ConstructionAcceptance { $this } (time: { ?timeCA }) must occur after DefectElimCompletion { ?defectComp } (time: { ?timeDEC })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE D INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseDInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseD_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseD_Instant' must belong to exactly one 'occp:PhaseD_Usage' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE D - USAGE
                
            osh:UsageStartShape a sh:NodeShape ;      # Instant Usage Start (Phase D - Usage)
                sh:targetClass occp:UsageStart ;
                # Instant (Usage Start) starts a new Phase D (Usage)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:UsageStart' must start exactly one 'occp:PhaseD_Usage' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageStart occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constrAccept ?timeUS ?timeCA
                        WHERE {
                            # Get time of UsageStart (actual or estimated)
                            { $this occp:hasActualTime ?timeUS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUS . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?constrAccept a occp:ConstructionAcceptance .
                            { ?constrAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constrAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeUS <= ?timeCA)
                        }
                    """ ;
                    sh:message "UsageStart { $this } (time: { ?timeUS }) must occur after ConstructionAcceptance { ?constrAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageStart occurs before UsageEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageEnd ?timeUS ?timeUE
                        WHERE {
                            # Get time of UsageStart (actual or estimated)
                            { $this occp:hasActualTime ?timeUS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUS . }
                            # Get time of UsageEnd (actual or estimated)
                            ?usageEnd a occp:UsageEnd .
                            { ?usageEnd occp:hasActualTime ?timeUE . }
                            UNION
                            { ?usageEnd occp:hasEstimatedTime ?timeUE . }
                            FILTER (?timeUS >= ?timeUE)
                        }
                    """ ;
                    sh:message "UsageStart { $this } (time: { ?timeUS }) must occur before UsageEnd { ?usageEnd } (time: { ?timeUE })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:UsageChangeShape a sh:NodeShape ;      # Instant Usage Change (Phase D - Usage)
                sh:targetClass occp:UsageChange ;
                # The current Usage Phase is ended with a Change of Usage
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:UsageChange' must end at least one 'occp:PhaseD_Usage' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # A new Usage Phase is started with a Change of Usage
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:UsageChange' must start at least one 'occp:PhaseD_Usage' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageChange occurs after CompletionOfConstruction based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?compConstr ?timeUC ?timeCOC
                        WHERE {
                            # Get time of UsageChange (actual or estimated)
                            { $this occp:hasActualTime ?timeUC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUC . }
                            # Get time of CompletionOfConstruction (actual or estimated)
                            ?compConstr a occp:CompletionOfConstruction .
                            { ?compConstr occp:hasActualTime ?timeCOC . }
                            UNION
                            { ?compConstr occp:hasEstimatedTime ?timeCOC . }
                            FILTER (?timeUC <= ?timeCOC)
                        }
                    """ ;
                    sh:message "UsageChange { $this } (time: { ?timeUC }) must occur after CompletionOfConstruction { ?compConstr } (time: { ?timeCOC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageChange occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeUC ?timeUS
                        WHERE {
                            # Get time of UsageChange (actual or estimated)
                            { $this occp:hasActualTime ?timeUC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUC . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeUC <= ?timeUS)
                        }
                    """ ;
                    sh:message "UsageChange { $this } (time: { ?timeUC }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageChange occurs before UsageEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageEnd ?timeUC ?timeUE
                        WHERE {
                            # Get time of UsageChange (actual or estimated)
                            { $this occp:hasActualTime ?timeUC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUC . }
                            # Get time of UsageEnd (actual or estimated)
                            ?usageEnd a occp:UsageEnd .
                            { ?usageEnd occp:hasActualTime ?timeUE . }
                            UNION
                            { ?usageEnd occp:hasEstimatedTime ?timeUE . }
                            FILTER (?timeUC >= ?timeUE)
                        }
                    """ ;
                    sh:message "UsageChange { $this } (time: { ?timeUC }) must occur before UsageEnd { ?usageEnd } (time: { ?timeUE })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageChange occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeUC ?timeDS
                        WHERE {
                            # Get time of UsageChange (actual or estimated)
                            { $this occp:hasActualTime ?timeUC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUC . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeUC >= ?timeDS)
                        }
                    """ ;
                    sh:message "UsageChange { $this } (time: { ?timeUC }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:UsageEndShape a sh:NodeShape ;      # Instant Usage End (Phase D - Usage)
                sh:targetClass occp:UsageEnd ;
                # Instant (Usage End) ends a Usage Phase
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseD_Usage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:UsageEnd' must end exactly one 'occp:PhaseD_Usage' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageEnd occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeUE ?timeUS
                        WHERE {
                            # Get time of UsageEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeUE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUE . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeUE <= ?timeUS)
                        }
                    """ ;
                    sh:message "UsageEnd { $this } (time: { ?timeUE }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageEnd occurs after UsageChange based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageChange ?timeUE ?timeUC
                        WHERE {
                            # Get time of UsageEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeUE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUE . }
                            # Get time of UsageChange (actual or estimated)
                            ?usageChange a occp:UsageChange .
                            { ?usageChange occp:hasActualTime ?timeUC . }
                            UNION
                            { ?usageChange occp:hasEstimatedTime ?timeUC . }
                            FILTER (?timeUE <= ?timeUC)
                        }
                    """ ;
                    sh:message "UsageEnd { $this } (time: { ?timeUE }) must occur after UsageChange { ?usageChange } (time: { ?timeUC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure UsageEnd occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeUE ?timeDS
                        WHERE {
                            # Get time of UsageEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeUE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeUE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeUE >= ?timeDS)
                        }
                    """ ;
                    sh:message "UsageEnd { $this } (time: { ?timeUE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE E INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseEInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseE_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseE_Instant' must belong to exactly one 'occp:PhaseE_Warranty' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE E - WARRANTY
            osh:WarrantyStartShape a sh:NodeShape ;          # Instant Warranty Start (Phase E - Warranty)
                sh:targetClass occp:WarrantyStart ;
                # Instant (Warranty Start) starts a new Phase E (Warranty)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:WarrantyStart' must start exactly one 'occp:PhaseE_Warranty' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyStart occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?acceptance ?timeWS ?timeCA
                        WHERE {
                            # Get time of WarrantyStart (actual or estimated)
                            { $this occp:hasActualTime ?timeWS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWS . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?acceptance a occp:ConstructionAcceptance .
                            { ?acceptance occp:hasActualTime ?timeCA . }
                            UNION
                            { ?acceptance occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeWS <= ?timeCA)
                        }
                    """ ;
                    sh:message "WarrantyStart { $this } (time: { ?timeWS }) must occur after ConstructionAcceptance { ?acceptance } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyStart occurs before WarrantyEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?end ?timeWS ?timeWE
                        WHERE {
                            # Get time of WarrantyStart (actual or estimated)
                            { $this occp:hasActualTime ?timeWS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWS . }
                            # Get time of WarrantyEnd (actual or estimated)
                            ?end a occp:WarrantyEnd .
                            { ?end occp:hasActualTime ?timeWE . }
                            UNION
                            { ?end occp:hasEstimatedTime ?timeWE . }
                            FILTER (?timeWS >= ?timeWE)
                        }
                    """ ;
                    sh:message "WarrantyStart { $this } (time: { ?timeWS }) must occur before WarrantyEnd { ?end } (time: { ?timeWE })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:WarrantyChangeShape a sh:NodeShape ;         # Instant Warranty Change (Phase E - Warranty)
                sh:targetClass occp:WarrantyChange ;
                # The current Warranty Phase is ended with a Change of Warranty
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:WarrantyChange' must end at least one 'occp:PhaseE_Warranty' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # A new Warranty Phase is started with a Change of Warranty
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:WarrantyChange' must start at least one 'occp:PhaseE_Warranty' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyChange occurs after CompletionOfConstruction based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeWC ?timeCOC
                        WHERE {
                            # Get time of WarrantyChange (actual or estimated)
                            { $this occp:hasActualTime ?timeWC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWC . }
                            # Get time of CompletionOfConstruction (actual or estimated)
                            ?completion a occp:CompletionOfConstruction .
                            { ?completion occp:hasActualTime ?timeCOC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeCOC . }
                            FILTER (?timeWC <= ?timeCOC)
                        }
                    """ ;
                    sh:message "WarrantyChange { $this } (time: { ?timeWC }) must occur after CompletionOfConstruction { ?completion } (time: { ?timeCOC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyChange occurs after WarrantyStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?start ?timeWC ?timeWS
                        WHERE {
                            # Get time of WarrantyChange (actual or estimated)
                            { $this occp:hasActualTime ?timeWC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWC . }
                            # Get time of WarrantyStart (actual or estimated)
                            ?start a occp:WarrantyStart .
                            { ?start occp:hasActualTime ?timeWS . }
                            UNION
                            { ?start occp:hasEstimatedTime ?timeWS . }
                            FILTER (?timeWC <= ?timeWS)
                        }
                    """ ;
                    sh:message "WarrantyChange { $this } (time: { ?timeWC }) must occur after WarrantyStart { ?start } (time: { ?timeWS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyChange occurs before WarrantyEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?end ?timeWC ?timeWE
                        WHERE {
                            # Get time of WarrantyChange (actual or estimated)
                            { $this occp:hasActualTime ?timeWC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWC . }
                            # Get time of WarrantyEnd (actual or estimated)
                            ?end a occp:WarrantyEnd .
                            { ?end occp:hasActualTime ?timeWE . }
                            UNION
                            { ?end occp:hasEstimatedTime ?timeWE . }
                            FILTER (?timeWC >= ?timeWE)
                        }
                    """ ;
                    sh:message "WarrantyChange { $this } (time: { ?timeWC }) must occur before WarrantyEnd { ?end } (time: { ?timeWE })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyChange occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeWC ?timeDS
                        WHERE {
                            # Get time of WarrantyChange (actual or estimated)
                            { $this occp:hasActualTime ?timeWC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWC . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeWC >= ?timeDS)
                        }
                    """ ;
                    sh:message "WarrantyChange { $this } (time: { ?timeWC }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:WarrantyEndShape a sh:NodeShape ;            # Instant Warranty End (Phase E - Warranty)
                sh:targetClass occp:WarrantyEnd ;
                # The current Warranty Phase is ended with Warranty End
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseE_Warranty ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:WarrantyEnd' must end exactly one 'occp:PhaseE_Warranty' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyEnd occurs after WarrantyStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?start ?timeWE ?timeWS
                        WHERE {
                            # Get time of WarrantyEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of WarrantyStart (actual or estimated)
                            ?start a occp:WarrantyStart .
                            { ?start occp:hasActualTime ?timeWS . }
                            UNION
                            { ?start occp:hasEstimatedTime ?timeWS . }
                            FILTER (?timeWE <= ?timeWS)
                        }
                    """ ;
                    sh:message "WarrantyEnd { $this } (time: { ?timeWE }) must occur after WarrantyStart { ?start } (time: { ?timeWS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyEnd occurs after WarrantyChange based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?change ?timeWE ?timeWC
                        WHERE {
                            # Get time of WarrantyEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of WarrantyChange (actual or estimated)
                            ?change a occp:WarrantyChange .
                            { ?change occp:hasActualTime ?timeWC . }
                            UNION
                            { ?change occp:hasEstimatedTime ?timeWC . }
                            FILTER (?timeWE <= ?timeWC)
                        }
                    """ ;
                    sh:message "WarrantyEnd { $this } (time: { ?timeWE }) must occur after WarrantyChange { ?change } (time: { ?timeWC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WarrantyEnd occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeWE ?timeDS
                        WHERE {
                            # Get time of WarrantyEnd (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeWE >= ?timeDS)
                        }
                    """ ;
                    sh:message "WarrantyEnd { $this } (time: { ?timeWE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE F INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseFInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseF_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseF_Instant' must belong to exactly one 'occp:PhaseF_DesignLife' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE F - DESIGN LIFE
            osh:DesignLifeStartShape a sh:NodeShape ;        # Instant Design Life Start (Phase F - Design Life)
                sh:targetClass occp:DesignLifeStart ;
                # Instant (Design Life Start) starts a new Phase F (Design Life)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DesignLifeStart' must start exactly one 'occp:PhaseF_DesignLife' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeStart occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeDLS ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeDLS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLS . }
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDLS <= ?timeCA)
                        }
                    """ ;
                    sh:message "DesignLifeStart { $this } (time: { ?timeDLS }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeStart occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconstStart ?timeDLS ?timeDS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLS . }
                            ?deconstStart a occp:DeconstructionStart .
                            { ?deconstStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconstStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDLS >= ?timeDS)
                        }
                    """ ;
                    sh:message "DesignLifeStart { $this } (time: { ?timeDLS }) must occur before DeconstructionStart { ?deconstStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeStart occurs before DesignLifeEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designEnd ?timeDLS ?timeDLE
                        WHERE {
                            { $this occp:hasActualTime ?timeDLS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLS . }
                            ?designEnd a occp:DesignLifeEnd .
                            { ?designEnd occp:hasActualTime ?timeDLE . }
                            UNION
                            { ?designEnd occp:hasEstimatedTime ?timeDLE . }
                            FILTER (?timeDLS >= ?timeDLE)
                        }
                    """ ;
                    sh:message "DesignLifeStart { $this } (time: { ?timeDLS }) must occur before DesignLifeEnd { ?designEnd } (time: { ?timeDLE })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DesignLifeChangeShape a sh:NodeShape ;       # Instant Design Life Change (Phase F - Design Life)
                sh:targetClass occp:DesignLifeChange ;
                # The current Design Life Phase is ended with a Change of Design Life
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:DesignLifeChange' must end at least one 'occp:PhaseF_DesignLife' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # A new Design Life Phase is started with a Change of Design Life
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:message "Each 'occp:DesignLifeChange' must start at least one 'occp:PhaseF_DesignLife' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeChange occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeDLC ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeDLC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLC . }
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDLC <= ?timeCA)
                        }
                    """ ;
                    sh:message "DesignLifeChange { $this } (time: { ?timeDLC }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeChange occurs after DesignLifeStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designStart ?timeDLC ?timeDLS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLC . }
                            ?designStart a occp:DesignLifeStart .
                            { ?designStart occp:hasActualTime ?timeDLS . }
                            UNION
                            { ?designStart occp:hasEstimatedTime ?timeDLS . }
                            FILTER (?timeDLC <= ?timeDLS)
                        }
                    """ ;
                    sh:message "DesignLifeChange { $this } (time: { ?timeDLC }) must occur after DesignLifeStart { ?designStart } (time: { ?timeDLS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeChange occurs before DesignLifeEnd based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designEnd ?timeDLC ?timeDLE
                        WHERE {
                            { $this occp:hasActualTime ?timeDLC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLC . }
                            ?designEnd a occp:DesignLifeEnd .
                            { ?designEnd occp:hasActualTime ?timeDLE . }
                            UNION
                            { ?designEnd occp:hasEstimatedTime ?timeDLE . }
                            FILTER (?timeDLC >= ?timeDLE)
                        }
                    """ ;
                    sh:message "DesignLifeChange { $this } (time: { ?timeDLC }) must occur before DesignLifeEnd { ?designEnd } (time: { ?timeDLE })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeChange occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconstStart ?timeDLC ?timeDS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLC . }
                            ?deconstStart a occp:DeconstructionStart .
                            { ?deconstStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconstStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDLC >= ?timeDS)
                        }
                    """ ;
                    sh:message "DesignLifeChange { $this } (time: { ?timeDLC }) must occur before DeconstructionStart { ?deconstStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DesignLifeEndShape a sh:NodeShape ;          # Instant Design Life End (Phase F - Design Life)
                sh:targetClass occp:DesignLifeEnd ;
                # The current Design Life Phase is ended with Design Life End
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseF_DesignLife ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DesignLifeEnd' must end exactly one 'occp:PhaseF_DesignLife' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeEnd occurs after DesignLifeStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designStart ?timeDLE ?timeDLS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLE . }
                            ?designStart a occp:DesignLifeStart .
                            { ?designStart occp:hasActualTime ?timeDLS . }
                            UNION
                            { ?designStart occp:hasEstimatedTime ?timeDLS . }
                            FILTER (?timeDLE <= ?timeDLS)
                        }
                    """ ;
                    sh:message "DesignLifeEnd { $this } (time: { ?timeDLE }) must occur after DesignLifeStart { ?designStart } (time: { ?timeDLS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeEnd occurs after DesignLifeChange based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?designChange ?timeDLE ?timeDLC
                        WHERE {
                            { $this occp:hasActualTime ?timeDLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLE . }
                            ?designChange a occp:DesignLifeChange .
                            { ?designChange occp:hasActualTime ?timeDLC . }
                            UNION
                            { ?designChange occp:hasEstimatedTime ?timeDLC . }
                            FILTER (?timeDLE <= ?timeDLC)
                        }
                    """ ;
                    sh:message "DesignLifeEnd { $this } (time: { ?timeDLE }) must occur after DesignLifeChange { ?designChange } (time: { ?timeDLC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeEnd occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeDLE ?timeCA
                        WHERE {
                            { $this occp:hasActualTime ?timeDLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLE . }
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDLE <= ?timeCA)
                        }
                    """ ;
                    sh:message "DesignLifeEnd { $this } (time: { ?timeDLE }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DesignLifeEnd occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconstStart ?timeDLE ?timeDS
                        WHERE {
                            { $this occp:hasActualTime ?timeDLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDLE . }
                            ?deconstStart a occp:DeconstructionStart .
                            { ?deconstStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconstStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDLE >= ?timeDS)
                        }
                    """ ;
                    sh:message "DesignLifeEnd { $this } (time: { ?timeDLE }) must occur before DeconstructionStart { ?deconstStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

        
    ### PHASE G INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseGInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseG_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseG_Inspection ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseG_Instant' must belong to exactly one 'occp:PhaseG_Inspection' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE G - INSPECTION
            osh:InspectionExecutionShape a sh:NodeShape ;    # Instant Inspection Execution (Phase G - Inspection)
                sh:targetClass occp:InspectionExecution ;
                # Ensure InspectionExecution occurs after ConstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constStart ?timeIE ?timeCS
                        WHERE {
                            # Get time of InspectionExecution (actual or estimated)
                            { $this occp:hasActualTime ?timeIE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeIE . }
                            # Get time of ConstructionStart (actual or estimated)
                            ?constStart a occp:ConstructionStart .
                            { ?constStart occp:hasActualTime ?timeCS . }
                            UNION
                            { ?constStart occp:hasEstimatedTime ?timeCS . }
                            FILTER (?timeIE <= ?timeCS)
                        }
                    """ ;
                    sh:message "InspectionExecution { $this } (time: { ?timeIE }) must occur after ConstructionStart { ?constStart } (time: { ?timeCS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure InspectionExecution occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeIE ?timeUS
                        WHERE {
                            # Get time of InspectionExecution (actual or estimated)
                            { $this occp:hasActualTime ?timeIE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeIE . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeIE <= ?timeUS)
                        }
                    """ ;
                    sh:message "InspectionExecution { $this } (time: { ?timeIE }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure InspectionExecution occurs after UsageChange based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageChange ?timeIE ?timeUC
                        WHERE {
                            # Get time of InspectionExecution (actual or estimated)
                            { $this occp:hasActualTime ?timeIE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeIE . }
                            # Get time of UsageChange (actual or estimated)
                            ?usageChange a occp:UsageChange .
                            { ?usageChange occp:hasActualTime ?timeUC . }
                            UNION
                            { ?usageChange occp:hasEstimatedTime ?timeUC . }
                            FILTER (?timeIE <= ?timeUC)
                        }
                    """ ;
                    sh:message "InspectionExecution { $this } (time: { ?timeIE }) must occur after UsageChange { ?usageChange } (time: { ?timeUC })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure InspectionExecution occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeIE ?timeDS
                        WHERE {
                            # Get time of InspectionExecution (actual or estimated)
                            { $this occp:hasActualTime ?timeIE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeIE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeIE >= ?timeDS)
                        }
                    """ ;
                    sh:message "InspectionExecution { $this } (time: { ?timeIE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:IrregularInspectionShape a sh:NodeShape ;    # Instant Irregular Inspection (Phase G - Inspection)
                sh:targetClass occp:IrregularInspection ;
                # Ensure IrregularInspection occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeII ?timeUS
                        WHERE {
                            # Get time of IrregularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeII . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeII . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeII <= ?timeUS)
                        }
                    """ ;
                    sh:message "IrregularInspection { $this } (time: { ?timeII }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure IrregularInspection occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeII ?timeDS
                        WHERE {
                            # Get time of IrregularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeII . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeII . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeII >= ?timeDS)
                        }
                    """ ;
                    sh:message "IrregularInspection { $this } (time: { ?timeII }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:NextRegularInspectionShape a sh:NodeShape ;  # Instant Next Regular Inspection (Phase G - Inspection)
                sh:targetClass occp:NextRegularInspection ;
                # Ensure NextRegularInspection occurs after InspectionExecution based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?inspExec ?timeNRI ?timeIE
                        WHERE {
                            # Get time of NextRegularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeNRI . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeNRI . }
                            # Get time of InspectionExecution (actual or estimated)
                            ?inspExec a occp:InspectionExecution .
                            { ?inspExec occp:hasActualTime ?timeIE . }
                            UNION
                            { ?inspExec occp:hasEstimatedTime ?timeIE . }
                            FILTER (?timeNRI <= ?timeIE)
                        }
                    """ ;
                    sh:message "NextRegularInspection { $this } (time: { ?timeNRI }) must occur after InspectionExecution { ?inspExec } (time: { ?timeIE })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure NextRegularInspection occurs after UsageStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?usageStart ?timeNRI ?timeUS
                        WHERE {
                            # Get time of NextRegularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeNRI . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeNRI . }
                            # Get time of UsageStart (actual or estimated)
                            ?usageStart a occp:UsageStart .
                            { ?usageStart occp:hasActualTime ?timeUS . }
                            UNION
                            { ?usageStart occp:hasEstimatedTime ?timeUS . }
                            FILTER (?timeNRI <= ?timeUS)
                        }
                    """ ;
                    sh:message "NextRegularInspection { $this } (time: { ?timeNRI }) must occur after UsageStart { ?usageStart } (time: { ?timeUS })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure NextRegularInspection occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeNRI ?timeDS
                        WHERE {
                            # Get time of NextRegularInspection (actual or estimated)
                            { $this occp:hasActualTime ?timeNRI . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeNRI . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeNRI >= ?timeDS)
                        }
                    """ ;
                    sh:message "NextRegularInspection { $this } (time: { ?timeNRI }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE H INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseHInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseH_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseH_SpecialEvents ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseH_Instant' must belong to exactly one 'occp:PhaseH_SpecialEvents' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE H - SPECIAL EVENTS
            osh:GeologicalEventShape a sh:NodeShape ;        # Instant Geological Event (Phase H - Special Events)
                sh:targetClass occp:GeologicalEvent ;
                # Ensure GeologicalEvent occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeGE ?timeCA
                        WHERE {
                            # Get time of GeologicalEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeGE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeGE . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeGE <= ?timeCA)
                        }
                    """ ;
                    sh:message "GeologicalEvent { $this } (time: { ?timeGE }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure GeologicalEvent occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeGE ?timeDS
                        WHERE {
                            # Get time of GeologicalEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeGE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeGE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeGE >= ?timeDS)
                        }
                    """ ;
                    sh:message "GeologicalEvent { $this } (time: { ?timeGE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:LoadEventShape a sh:NodeShape ;              # Instant Load Event (Phase H - Special Events)
                sh:targetClass occp:LoadEvent ;
                # Ensure LoadEvent occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeLE ?timeCA
                        WHERE {
                            # Get time of LoadEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeLE . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeLE <= ?timeCA)
                        }
                    """ ;
                    sh:message "LoadEvent { $this } (time: { ?timeLE }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure LoadEvent occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeLE ?timeDS
                        WHERE {
                            # Get time of LoadEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeLE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeLE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeLE >= ?timeDS)
                        }
                    """ ;
                    sh:message "LoadEvent { $this } (time: { ?timeLE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:WeatherEventShape a sh:NodeShape ;           # Instant Weather Event (Phase H - Special Events)
                sh:targetClass occp:WeatherEvent ;
                # Ensure WeatherEvent occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?constAccept ?timeWE ?timeCA
                        WHERE {
                            # Get time of WeatherEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?constAccept a occp:ConstructionAcceptance .
                            { ?constAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?constAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeWE <= ?timeCA)
                        }
                    """ ;
                    sh:message "WeatherEvent { $this } (time: { ?timeWE }) must occur after ConstructionAcceptance { ?constAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure WeatherEvent occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeWE ?timeDS
                        WHERE {
                            # Get time of WeatherEvent (actual or estimated)
                            { $this occp:hasActualTime ?timeWE . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeWE . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeWE >= ?timeDS)
                        }
                    """ ;
                    sh:message "WeatherEvent { $this } (time: { ?timeWE }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE K INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseKInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseK_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseK_Damage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseK_Instant' must belong to exactly one 'occp:PhaseK_Damage' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE K - DAMAGE
            osh:DamageDetectionShape a sh:NodeShape ;        # Instant Damage Detection (Phase K - Damage)
                sh:targetClass occp:DamageDetection ;
                # Instant (Damage Detection) starts a new Phase K (Damage)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseK_Damage ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DamageDetection' must start exactly one 'occp:PhaseK_Damage' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DamageDetection occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?conAccept ?timeDD ?timeCA
                        WHERE {
                            # Get time of DamageDetection (actual or estimated)
                            { $this occp:hasActualTime ?timeDD . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDD . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?conAccept a occp:ConstructionAcceptance .
                            { ?conAccept occp:hasActualTime ?timeCA . }
                            UNION
                            { ?conAccept occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDD <= ?timeCA)
                        }
                    """ ;
                    sh:message "DamageDetection { $this } (time: { ?timeDD }) must occur after ConstructionAcceptance { ?conAccept } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DamageDetection occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeDD ?timeDS
                        WHERE {
                            # Get time of DamageDetection (actual or estimated)
                            { $this occp:hasActualTime ?timeDD . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDD . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDD >= ?timeDS)
                        }
                    """ ;
                    sh:message "DamageDetection { $this } (time: { ?timeDD }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DamageObservationShape a sh:NodeShape ;      # Instant Damage Observation (Phase K - Damage)
                sh:targetClass occp:DamageObservation ;
                # Ensure DamageObservation occurs after DamageDetection based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?damageDetect ?timeDO ?timeDD
                        WHERE {
                            # Get time of DamageObservation (actual or estimated)
                            { $this occp:hasActualTime ?timeDO . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDO . }
                            # Get time of DamageDetection (actual or estimated)
                            ?damageDetect a occp:DamageDetection .
                            { ?damageDetect occp:hasActualTime ?timeDD . }
                            UNION
                            { ?damageDetect occp:hasEstimatedTime ?timeDD . }
                            FILTER (?timeDO <= ?timeDD)
                        }
                    """ ;
                    sh:message "DamageObservation { $this } (time: { ?timeDO }) must occur after DamageDetection { ?damageDetect } (time: { ?timeDD })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DamageObservation occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeDO ?timeDS
                        WHERE {
                            # Get time of DamageObservation (actual or estimated)
                            { $this occp:hasActualTime ?timeDO . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDO . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDO >= ?timeDS)
                        }
                    """ ;
                    sh:message "DamageObservation { $this } (time: { ?timeDO }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DamageRepairShape a sh:NodeShape ;           # Instant Damage Repair (Phase K - Damage)
                sh:targetClass occp:DamageRepair ;
                # Ensure DamageRepair occurs after DamageDetection based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?damageDetect ?timeDR ?timeDD
                        WHERE {
                            # Get time of DamageRepair (actual or estimated)
                            { $this occp:hasActualTime ?timeDR . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDR . }
                            # Get time of DamageDetection (actual or estimated)
                            ?damageDetect a occp:DamageDetection .
                            { ?damageDetect occp:hasActualTime ?timeDD . }
                            UNION
                            { ?damageDetect occp:hasEstimatedTime ?timeDD . }
                            FILTER (?timeDR <= ?timeDD)
                        }
                    """ ;
                    sh:message "DamageRepair { $this } (time: { ?timeDR }) must occur after DamageDetection { ?damageDetect } (time: { ?timeDD })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DamageRepair occurs before DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?deconStart ?timeDR ?timeDS
                        WHERE {
                            # Get time of DamageRepair (actual or estimated)
                            { $this occp:hasActualTime ?timeDR . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDR . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?deconStart a occp:DeconstructionStart .
                            { ?deconStart occp:hasActualTime ?timeDS . }
                            UNION
                            { ?deconStart occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDR >= ?timeDS)
                        }
                    """ ;
                    sh:message "DamageRepair { $this } (time: { ?timeDR }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation
                ] .


    ### PHASE L INSTANTS
        # PHASE ASSIGNMENT
        osh:NewComponentShape a sh:NodeShape ;           # Instant New Component (Phase L - Repair)
            sh:targetClass occp:NewComponent ;
            # Ensure NewComponent occurs after ConstructionCompletion based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?constComp ?timeNC ?timeCC
                    WHERE {
                        # Get time of NewComponent (actual or estimated)
                        { $this occp:hasActualTime ?timeNC . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeNC . }
                        # Get time of ConstructionCompletion (actual or estimated)
                        ?constComp a occp:ConstructionCompletion .
                        { ?constComp occp:hasActualTime ?timeCC . }
                        UNION
                        { ?constComp occp:hasEstimatedTime ?timeCC . }
                        FILTER (?timeNC <= ?timeCC)
                    }
                """ ;
                sh:message "NewComponent { $this } (time: { ?timeNC }) must occur after ConstructionCompletion { ?constComp } (time: { ?timeCC })."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure NewComponent occurs before DeconstructionStart based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?deconStart ?timeNC ?timeDS
                    WHERE {
                        # Get time of NewComponent (actual or estimated)
                        { $this occp:hasActualTime ?timeNC . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeNC . }
                        # Get time of DeconstructionStart (actual or estimated)
                        ?deconStart a occp:DeconstructionStart .
                        { ?deconStart occp:hasActualTime ?timeDS . }
                        UNION
                        { ?deconStart occp:hasEstimatedTime ?timeDS . }
                        FILTER (?timeNC >= ?timeDS)
                    }
                """ ;
                sh:message "NewComponent { $this } (time: { ?timeNC }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                sh:severity sh:Violation
            ] .

        osh:RepairStartShape a sh:NodeShape ;            # Instant Repair Start (Phase L - Repair)
            sh:targetClass occp:RepairStart ;
            # Instant (Repair Start) starts a new Phase L (Repair)
            sh:property [
                sh:path occp:startsPhase ;
                sh:class occp:PhaseL_Repair ;
                sh:minCount 1 ;
                sh:maxCount 1 ;
                sh:message "Each 'occp:RepairStart' must start exactly one 'occp:PhaseL_Repair' via 'occp:startsPhase'."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairStart occurs after DamageDetection based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?damageDet ?timeRS ?timeDD
                    WHERE {
                        # Get time of RepairStart (actual or estimated)
                        { $this occp:hasActualTime ?timeRS . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRS . }
                        # Get time of DamageDetection (actual or estimated)
                        ?damageDet a occp:DamageDetection .
                        { ?damageDet occp:hasActualTime ?timeDD . }
                        UNION
                        { ?damageDet occp:hasEstimatedTime ?timeDD . }
                        FILTER (?timeRS <= ?timeDD)
                    }
                """ ;
                sh:message "RepairStart { $this } (time: { ?timeRS }) must occur after DamageDetection { ?damageDet } (time: { ?timeDD })."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairStart occurs before RepairCompletion based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?repairComp ?timeRS ?timeRC
                    WHERE {
                        # Get time of RepairStart (actual or estimated)
                        { $this occp:hasActualTime ?timeRS . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRS . }
                        # Get time of RepairCompletion (actual or estimated)
                        ?repairComp a occp:RepairCompletion .
                        { ?repairComp occp:hasActualTime ?timeRC . }
                        UNION
                        { ?repairComp occp:hasEstimatedTime ?timeRC . }
                        FILTER (?timeRS >= ?timeRC)
                    }
                """ ;
                sh:message "RepairStart { $this } (time: { ?timeRS }) must occur before RepairCompletion { ?repairComp } (time: { ?timeRC })."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairStart occurs before DeconstructionStart based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?deconStart ?timeRS ?timeDS
                    WHERE {
                        # Get time of RepairStart (actual or estimated)
                        { $this occp:hasActualTime ?timeRS . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRS . }
                        # Get time of DeconstructionStart (actual or estimated)
                        ?deconStart a occp:DeconstructionStart .
                        { ?deconStart occp:hasActualTime ?timeDS . }
                        UNION
                        { ?deconStart occp:hasEstimatedTime ?timeDS . }
                        FILTER (?timeRS >= ?timeDS)
                    }
                """ ;
                sh:message "RepairStart { $this } (time: { ?timeRS }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                sh:severity sh:Violation
            ] .

        osh:RepairCompletionShape a sh:NodeShape ;       # Instant Repair Completion (Phase L - Repair)
            sh:targetClass occp:RepairCompletion ;
            # Instant (Repair Completion) ends a Phase L (Repair)
            sh:property [
                sh:path occp:endsPhase ;
                sh:class occp:PhaseL_Repair ;
                sh:minCount 1 ;
                sh:maxCount 1 ;
                sh:message "Each 'occp:RepairCompletion' must end exactly one 'occp:PhaseL_Repair' via 'occp:endsPhase'."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairCompletion occurs after RepairStart based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?repairStart ?timeRC ?timeRS
                    WHERE {
                        # Get time of RepairCompletion (actual or estimated)
                        { $this occp:hasActualTime ?timeRC . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRC . }
                        # Get time of RepairStart (actual or estimated)
                        ?repairStart a occp:RepairStart .
                        { ?repairStart occp:hasActualTime ?timeRS . }
                        UNION
                        { ?repairStart occp:hasEstimatedTime ?timeRS . }
                        FILTER (?timeRC <= ?timeRS)
                    }
                """ ;
                sh:message "RepairCompletion { $this } (time: { ?timeRC }) must occur after RepairStart { ?repairStart } (time: { ?timeRS })."@en ;
                sh:severity sh:Violation
            ] ;
            # Ensure RepairCompletion occurs before DeconstructionStart based on actual or estimated times
            sh:sparql [
                sh:select """
                    PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                    PREFIX time: <http://www.w3.org/2006/time#>
                    SELECT $this ?deconStart ?timeRC ?timeDS
                    WHERE {
                        # Get time of RepairCompletion (actual or estimated)
                        { $this occp:hasActualTime ?timeRC . }
                        UNION
                        { $this occp:hasEstimatedTime ?timeRC . }
                        # Get time of DeconstructionStart (actual or estimated)
                        ?deconStart a occp:DeconstructionStart .
                        { ?deconStart occp:hasActualTime ?timeDS . }
                        UNION
                        { ?deconStart occp:hasEstimatedTime ?timeDS . }
                        FILTER (?timeRC >= ?timeDS)
                    }
                """ ;
                sh:message "RepairCompletion { $this } (time: { ?timeRC }) must occur before DeconstructionStart { ?deconStart } (time: { ?timeDS })."@en ;
                sh:severity sh:Violation
            ] .


    ### PHASE M INSTANTS
        # PHASE ASSIGNMENT
            osh:PhaseMInstantShape a sh:NodeShape ;
                sh:targetClass occp:PhaseM_Instant ;
                sh:property [
                    sh:path occp:hasPhase ;
                    sh:class occp:PhaseM_Deconstruction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:PhaseM_Instant' must belong to exactly one 'occp:PhaseM_Deconstruction' via 'occp:hasPhase'."@en ;
                    sh:severity sh:Violation ;
                ] .

        ### INSTANT SHAPES PHASE M - DECONSTRUCTION
            osh:DeconstructionStartShape a sh:NodeShape ;    # Instant Deconstruction Start (Phase M - Deconstruction)
                sh:targetClass occp:DeconstructionStart ;
                # Instant (Deconstruction Start) starts a new Phase M (Deconstruction)
                sh:property [
                    sh:path occp:startsPhase ;
                    sh:class occp:PhaseM_Deconstruction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DeconstructionStart' must start exactly one 'occp:PhaseM_Deconstruction' via 'occp:startsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DeconstructionStart occurs after ConstructionAcceptance based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?acceptance ?timeDS ?timeCA
                        WHERE {
                            # Get time of DeconstructionStart (actual or estimated)
                            { $this occp:hasActualTime ?timeDS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDS . }
                            # Get time of ConstructionAcceptance (actual or estimated)
                            ?acceptance a occp:ConstructionAcceptance .
                            { ?acceptance occp:hasActualTime ?timeCA . }
                            UNION
                            { ?acceptance occp:hasEstimatedTime ?timeCA . }
                            FILTER (?timeDS <= ?timeCA)
                        }
                    """ ;
                    sh:message "DeconstructionStart { $this } (time: { ?timeDS }) must occur after ConstructionAcceptance { ?acceptance } (time: { ?timeCA })."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DeconstructionStart occurs before DeconstructionCompletion based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?completion ?timeDS ?timeDC
                        WHERE {
                            # Get time of DeconstructionStart (actual or estimated)
                            { $this occp:hasActualTime ?timeDS . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDS . }
                            # Get time of DeconstructionCompletion (actual or estimated)
                            ?completion a occp:DeconstructionCompletion .
                            { ?completion occp:hasActualTime ?timeDC . }
                            UNION
                            { ?completion occp:hasEstimatedTime ?timeDC . }
                            FILTER (?timeDS >= ?timeDC)
                        }
                    """ ;
                    sh:message "DeconstructionStart { $this } (time: { ?timeDS }) must occur before DeconstructionCompletion { ?completion } (time: { ?timeDC })."@en ;
                    sh:severity sh:Violation
                ] .

            osh:DeconstructionCompletionShape a sh:NodeShape ;   # Instant Deconstruction Completion (Phase M - Deconstruction)
                sh:targetClass occp:DeconstructionCompletion ;
                # Instant (Deconstruction Completion) ends a Phase M (Deconstruction)
                sh:property [
                    sh:path occp:endsPhase ;
                    sh:class occp:PhaseM_Deconstruction ;
                    sh:minCount 1 ;
                    sh:maxCount 1 ;
                    sh:message "Each 'occp:DeconstructionCompletion' must end exactly one 'occp:PhaseM_Deconstruction' via 'occp:endsPhase'."@en ;
                    sh:severity sh:Violation
                ] ;
                # Ensure DeconstructionCompletion occurs after DeconstructionStart based on actual or estimated times
                sh:sparql [
                    sh:select """
                        PREFIX occp: <http://www.semanticweb.org/albrechtvaatz/ontologies/2022/9/cMod_V0.1#>
                        PREFIX time: <http://www.w3.org/2006/time#>
                        SELECT $this ?start ?timeDC ?timeDS
                        WHERE {
                            # Get time of DeconstructionCompletion (actual or estimated)
                            { $this occp:hasActualTime ?timeDC . }
                            UNION
                            { $this occp:hasEstimatedTime ?timeDC . }
                            # Get time of DeconstructionStart (actual or estimated)
                            ?start a occp:DeconstructionStart .
                            { ?start occp:hasActualTime ?timeDS . }
                            UNION
                            { ?start occp:hasEstimatedTime ?timeDS . }
                            FILTER (?timeDC <= ?timeDS)
                        }
                    """ ;
                    sh:message "DeconstructionCompletion { $this } (time: { ?timeDC }) must occur after DeconstructionStart { ?start } (time: { ?timeDS })."@en ;
                    sh:severity sh:Violation ] .